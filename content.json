{"meta":{"title":"洽客前端","subtitle":"洽客技术团队 （QKED）","description":"Talk is cheap, Show me the code.","author":"LT","url":"http://www.qiakr.com"},"pages":[{"title":"关于我们","date":"2016-05-07T08:03:53.000Z","updated":"2016-05-07T08:58:44.000Z","comments":true,"path":"about/index.html","permalink":"http://www.qiakr.com/about/index.html","excerpt":"","keywords":null,"text":"洽客（Qiakr）隶属于杭州蚁国科技有限公司 是一家基于移动互联网,为传统零售企业提供创新型服务的公司 我们为线下实体零售商提供创新的零售方式","raw":null,"content":null}],"posts":[{"title":"模块编写规范","slug":"AMD-Module-guide","date":"2016-07-17T08:03:53.000Z","updated":"2016-07-17T08:30:16.000Z","comments":true,"path":"2016/07/17/AMD-Module-guide/","link":"","permalink":"http://www.qiakr.com/qkfe/2016/07/17/AMD-Module-guide/","excerpt":"React或Vue给我来带来的不是仅仅是View层的改变和便捷的组件化开发，更多的是围绕这套开发体系，整个技术栈的应用和实践。但很多管理系统还是基于传统的AMD或CMD开发，配合Jquery插件使用，所以日常的组件和模块编写应该有一定的规范，以减少多人配合开发的沟通成本，统一编码风格，便于维护管理，也便于后期重构切换到新的技术栈。","keywords":null,"text":"React或Vue给我来带来的不是仅仅是View层的改变和便捷的组件化开发，更多的是围绕这套开发体系，整个技术栈的应用和实践。但很多管理系统还是基于传统的AMD或CMD开发，配合Jquery插件使用，所以日常的组件和模块编写应该有一定的规范，以减少多人配合开发的沟通成本，统一编码风格，便于维护管理，也便于后期重构切换到新的技术栈。 是编写模块还是编写组件？模块与组件的区别 组件：可重用，对独立功能生命周期的封装。对外提供统一的配置和调用接口。遵循开闭原则：对外扩展开放，对内修改关闭。 模块：不可重用，对一个业务处理的封装，有独有的业务处理代码，可调用各种组件。 依赖jQuery的组件挂载为jQuery的静态方法 还是 挂载到jQuery的实例上？ 挂载到jQuery的实例上: 页面上需要实例化多个功能一样的组件时，依赖页面上的DOM结构，依赖父容器初始化 挂载为jQuery的静态方法: 不依赖页面上的DOM，以处理数据为主 独立的组件对纯数据层面的处理，比如常用的Utils模块、数据验证、xss模块、加密解密、cookie操作、特性检测等 设计思想由前往后 从前往后推，先构建使用方式和场景 首先应该想到的是组件或模块的使用方法，它有那些方法和属性，应该怎样初始化 需要预留怎么样的配置或接口去做模块的扩展 需要依赖的资源 结构和接口设计模块全局变量 CONF 模块配置: api地址，公用的配置和常量 pageVM 模块数据模型: 如果页面有大量表单元素，使用avalon的VM模型做数据的双向绑定，如果没有，则不需要此变量 pageView 模块业务逻辑: 页面主逻辑对象，包含：init/bindEvents/getData/initComponents等方法，init中只对业务做初始化操作 init 对外接口: 提供对外统一调用初始化方法 模块模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950define(['moment'],function(moment)&#123; var pageVM, CONF, pageView; // [ TODO: 模块配置 ] CONF=&#123; apiGetList:'getOrderList.json', &#125;; // [ TODO: 模块主逻辑处理 ] pageView = &#123; init: function()&#123; // [ TODO: 模块数据模型初始化 ] (建议有表单时使用) !pageVM &amp;&amp; this.initVM(); //初始化ViewModel this.initComponents(); // 初始化组件：select2、tolltip、uploader this.getListData(); //加载列表数据 this.selectChangeEv(); //注册下拉框变化事件 &#125;, initVM: function()&#123; pageVM = avalon.define(&#123; $id:'recordsCtr', searching:false, searchPms:&#123; status:'0', startTime:'', endTime:'', index:0, length:10, &#125; searchEv:function(e)&#123; e.preventDefault(); pageVM.searching=true; pageVM.searchPms.index=0; page.getListData(); &#125; &#125;); &#125;, selectChangeEv: function()&#123; ... &#125;, initComponents: function()&#123; ... &#125;, getListData: function()&#123; ... &#125; &#125; // [ TODO: 对外提供统一的调用接口 ] return &#123; init:function()&#123; pageView.init(); avalon.scan(); &#125; &#125;&#125;) 命名规则 接口名称： 以 api 开头 + 接口名 {apiGetSalesList:&#39;getSalesList&#39;} 事件名称： 事件名称 + 以 Ev 结尾 changeColorEv this指向修正：统一以 _this 命名 jQuery变量以$符号开头 $btnSearch=$(&#39;#btnSearch&#39;) 注意点 每个模块 init 是入口函数，也就是第一次加载时，整个模块代码顺序执行，以后的每次页面初始化，都只会执行init中的代码 每个模块 VM 中 $id 不允许重名 每个页面的artTemplate 模板id 不允许重名，因为模板有缓存，id相同会覆盖已有的模板 每个页面的DOM上的 id 尽量不要相同 数据加载处理要考虑的问题：数据列表加载的重用性、Loading触发的时机、何时需要分页、点击分页的处理、搜索处理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768getListData:function()&#123; // 构建查询参数 var pms = $.extend(&#123;&#125;,pageVM.$model.searchPms), url = CONF.apiGetList, //数据加载接口 $tbl = $('#listTbl'), //列表所在的容器 $tbdBox = $('#listTbd'), //列表项所在的tbody $total = $('#listTotal'), //数据总条数 $pageBox = $('#pageNumBox'); //分页容器 pms.startTime = Utils.getUnixTime(pms.startTime); pms.endTime = Utils.getUnixTime(pms.endTime); // 数据加载前显示Loading状态 $tbl.uiLoading('lg'); // 异步加载数据，并返回 deffered 对象 return $.post(url, pms) .done(function(data)&#123; if(data.status==='0')&#123; var listData = data.result.orderList, count = data.result.count; // 显示总数据条数 $total.text(count); //如果有数据 if(count&gt;0)&#123; // 渲染数据 $tbdBox.html(template('list_record_tpl', &#123;data: listData, url:CONF.orderUrl&#125;)); // 如果总数据条数大于请求的数据条数，就显示分页 if(count &gt; pms.length)&#123; $pageBox.pagination(&#123; totalData:count, coping:true, showData:pms.length, callback:function(i)&#123; // 计算起始索引 pms.index = (i-1)*pms.length; //显示Loading $tbl.uiLoading('lg'); //加载数据 $.post(url,pms) .done(function(data)&#123; // 渲染数据 $tbdBox.html(template('list_record_tpl', &#123;data: data.result.orderList, url:CONF.orderUrl&#125;)); // 隐藏Loading $tbl.uiLoading('lg'); &#125;); &#125; &#125;); &#125; &#125;else&#123; // 清空分页和列表数据，并添加为空说明 $tbdBox.html('&lt;tr&gt;&lt;td colspan=\"7\"&gt;&lt;p class=\"p20 c-8 text-center\"&gt; 未查询到相关数据 &lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;'); $pageBox.html(''); &#125; &#125;else&#123; // 提示加载失败信息 toastr.error(data.errmsg || '服务器繁忙！'); &#125; &#125;) .always(function()&#123; //加载失败时，隐藏loading状态 $tbl.uiLoading('lg'); pageVM.searching = false; &#125;);&#125;","raw":null,"content":null,"categories":[{"name":"web开发","slug":"web开发","permalink":"http://www.qiakr.com/categories/web开发/"}],"tags":[]},{"title":"组件编写规范","slug":"Component-define-guide","date":"2016-07-17T08:03:53.000Z","updated":"2016-07-17T08:28:45.000Z","comments":true,"path":"2016/07/17/Component-define-guide/","link":"","permalink":"http://www.qiakr.com/qkfe/2016/07/17/Component-define-guide/","excerpt":"组件的封装有利用于代码的复用，封装统一的数据处理逻辑，对外提供接口，灵活配置与扩展，调用方便，利于维护。","keywords":null,"text":"组件的封装有利用于代码的复用，封装统一的数据处理逻辑，对外提供接口，灵活配置与扩展，调用方便，利于维护。 原则 开闭原则：对内修改关闭，对外扩展开放 单例模式：同一个组件，在多次调用时，只使用一个单例 闭包使用闭包：减少全局变量的污染，避免与其它插件冲突 严格模式 (strict mode)使用严格模式：添加 use strict 标识 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的Javascript做好铺垫。 组件说明组件应添加组件说明，包含：组件名称、作者、版本、依赖项、使用方式、源码地址 12345678/*** module: Button* author: XXX* version: v0.0.1* use age: ....* deps: [...]* github: ...**/ 构造函数组件的状态和属性都应该在构造函数中进行初始化 插件定义通用插件定义 在内部返回每一个jQuery对象，插件的实例缓存到jQ对象的data中 要的参数的类型调用组件不同的方法 123456789function Plugin(option) &#123; return this.each(function () &#123; var $this = $(this) var data = $this.data('qk.button') if (!data) $this.data('qk.button', (data = new Button(this))) if (typeof option == 'string') data[option].call($this) &#125;) &#125; 事件的命名空间在开发较复杂的组件时，应添加事件命名空间，方便事件的管理，参见bootstrap modal组件 对外开放配置组件通常有很多的配置，将配置接口对外开放，可方便用户对组件进行详情的配置与自定义 1$.bn.button.defaults=&#123; ... &#125; 注意： 组件内部使用到的模板、class、id等都应该放到配置中，以便使用者自定义 对外开放构造器将构造器对外开放，可方便外部对插件进行扩展升级 1$.fn.button.Constructor = Button; 解决与其它重名插件的冲突为防止组件名称与其它组件重名，应对外提供onConflict接口进行重命名。 12var old = $.fn.button;$.fn.button.noConflict = function () &#123;$.fn.button = old;return this;&#125; 生命周期组件的生命周期包含：组件状态初始化、数据初始化、事件绑定、更新、销毁 结构 PUBLIC CLASS DEFINITION：类定义，定义了插件构造方法类及方法。 PLUGIN DEFINITION：插件定义，上面只是定义了插件的类，这里才是实现插件的地方。 PLUGIN NOCONFLICT:插件命名冲突解决 DATA-API：DATA-属性接口 模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/*** module: Button* author: XXX* version: v0.0.1* use age: ....* deps: [...]* github: ...**/!function ($) &#123; \"use strict\"; // CLASS DEFINITION // ================ var Button = function (element, options) &#123;/*some code*&#125; Button.VERSION='v1.0.1'; Button.prototype.setState = function (state) &#123;/*some code*/&#125; Button.prototype.toggle = function () &#123;/*some code*/&#125; // PLUGIN DEFINITION // ================= function Plugin(option) &#123; return this.each(function () &#123; var $this = $(this) var data = $this.data('qk.button') if (!data) $this.data('qk.button', (data = new Button(this))) if (typeof option == 'string') data[option].call($this) &#125;) &#125; var old = $.fn.button; $.fn.button = Plugin; $.fn.button.Constructor = Button; $.fn.button.defaults = &#123;loadingText: 'loading...'&#125; // NO CONFLICT // =========== $.fn.button.noConflict = function () &#123; $.fn.button = old; return this; &#125; // DATA-API // ======== $(document).on('click.button.data-api', '[data-toggle^=button]', function (e) &#123;/*some code*/&#125;)&#125;(jQuery, window, undefined);","raw":null,"content":null,"categories":[{"name":"web开发","slug":"web开发","permalink":"http://www.qiakr.com/categories/web开发/"}],"tags":[]},{"title":"ES5特性介绍","slug":"ES5-new-features","date":"2016-06-29T07:50:10.000Z","updated":"2016-06-29T08:09:17.000Z","comments":true,"path":"2016/06/29/ES5-new-features/","link":"","permalink":"http://www.qiakr.com/qkfe/2016/06/29/ES5-new-features/","excerpt":"2011年6月，ECMAscript 5.1版发布，并且成为ISO国际标准，简称ES5。","keywords":null,"text":"2011年6月，ECMAscript 5.1版发布，并且成为ISO国际标准，简称ES5。 浏览器支持IE9+ , Android Browser 4.3+, Safari5.1+, Chrome22+, FireFox20+, Opera12.1+ 严格模式在函数内顶部或模块顶部添加: &quot;use strict&quot;; 以开启对该作用域的语法检查。 在严格模式下有以下限制： 未声明的变量赋值抛出一个ReferenceError, 而不是创建一个全局变量。 var定义只能在函数级，if、for、while、switch等不能有var定义 一个对象字面量中不能声明两个名称相同的属性。一个函数也不能有名称相同的形式参数。 arguments 不能使用arguments、eval、let、const作为标识符(变量名方法名等) 不能修改作为函数内部对象的arguments，因此形式参数和arguments之间不再有同步变化 不能访问arguments.callee ES5中定义了arguments.caller属性，它的值始终是undefined，主要用于区分arguments.caller和函数的caller，但是不能在严格模式下访问 普通的函数调用中this是null 试图改变只读属性将会抛出异常 delete失败会抛出异常 eval中不再能声明变量，声明的函数将会变成全局的 12345678910function f1 (c1, c2)&#123; &apos;use strict&apos;; var arguments=9; // Unexpected eval or arguments in strict mode console.log(arguments); //[2, 3] console.log(arguments[0]); //2 arguments[0]=12; console.log(arguments[0]); //12 console.log(c1); //2 console.log(arguments.callee);//Uncaught TypeError: &apos;caller&apos;, &apos;callee&apos;, and &apos;arguments&apos; properties may not be accessed&#125; JSON对象ES5提供一个全局的JSON对象 JSON.stringify(obj, fn/arr, number) 序列化 第一个参数是待转换的 ECMAScript 对象， 第二个参数可以是一个函数或是数组。如果是函数，则转换的结果由该函数来确定；如果是数组，则只有出现在数组中的属性名称，才会出现在转换之后的结果中。 第三个参数是用来控制转换结果中文本的缩进，以更好的进行显示。 JSON.parse(str, fn) 反序列化 第一个参数是 JSON 文本，需要符合 JSON 格式的要求。 第二个参数是一个函数，可以用来对解析过程中得到的属性名值对进行过滤和转换。 1234567891011121314151617181920212223242526272829303132333435var jsonStr = &apos;&#123;&quot;a&quot;:1, &quot;b&quot;:2, &quot;c&quot;:3&#125;&apos;; JSON.parse(jsonStr); JSON.parse(jsonStr, function(key, value) &#123; return typeof value === &apos;number&apos; ? value * 2 : value; &#125;); // 结果为 &#123;a:2, b:4, c:6&#125; JSON.parse(jsonStr, function(key, value) &#123; return typeof value === &apos;number&apos; &amp;&amp; value % 2 === 0 ? undefined : value; &#125;); // 结果为 &#123;a:1, b:3&#125;var user = &#123; name : &apos;Alex&apos;, password : &apos;password&apos;, email : &apos;alex@example.org&apos; &#125;; JSON.stringify(user); JSON.stringify(user, [&apos;name&apos;]); // 输出结果为“&#123;&quot;name&quot;:&quot;Alex&quot;&#125;” JSON.stringify(user, function(key, value) &#123; if (key === &apos;email&apos;) &#123; return &apos;******&apos;; &#125; if (key === &apos;password&apos;) &#123; return undefined; &#125; return value; &#125;); // 输出结果为“&#123;&quot;name&quot;:&quot;Alex&quot;,&quot;email&quot;:&quot;******&quot;&#125;” JSON.stringify(user, null, 4);=&gt;&#123; &quot;name&quot;: &quot;Alex&quot;, &quot;password&quot;: &quot;password&quot;, &quot;email&quot;: &quot;alex@example.org&quot;&#125; 注意：JSON.parse()必须接收严格的JSON格式，否则报错，比如键名必须使用双引号括起来 Object的扩展对象的属性有了更多的控制 继承相关方法：create()、getPrototypeOf() 属性相关方法：defineProperty()、defineProperties()、getOwnPropertyDescriptor()、getOwnPropertyNames()、keys() 防篡改方法：preventExtensions()、isExtensible()、seal()、isSealed()、freeze()、isFrozen() Object.preventExtensions、Object.seal 和 Object.freeze 函数可以用来保护对象，防止被第三方有意或无意的修改。 123456789101112131415161718192021222324252627282930313233343536373839404142434445var cat = &#123;&#125;;Object.defineProperty(cat, &quot;name&quot;, &#123; value: &quot;Maru&quot;, writable: false, enumerable: true, configurable: false&#125;);Object.defineProperty(cat, &quot;skill&quot;, &#123; value: &quot;exploring boxes&quot;, writable: true, enumerable: true, configurable: true&#125;);var obj = &#123;&#125;; Object.defineProperty(obj, &apos;val&apos;, &#123;&#125;); // 创建一个新属性，特性为默认值obj.val = 1; Object.defineProperty(obj, &apos;CONSTANT&apos;, &#123;value : 32, writable : false&#125;); // 创建一个只读属性obj.CONSTANT = 16; // 对属性的修改是无效的，但是不会抛出错误Object.defineProperty(obj, &quot;newVal&quot;, &#123;enumerable: true&#125;); for (var key in obj) &#123; console.log(key); // 可以枚举出 newVal &#125;var initValue = 0; Object.defineProperty(obj, &quot;initValue&quot;, &#123; get : function() &#123; return initValue; &#125;, set : function(val) &#123; if (val &gt; 0) &#123; initValue = val; &#125; &#125; &#125;);var obj = &#123;val : 1&#125;; obj.newVal = &quot;Hello&quot;; Object.seal(obj); Object.defineProperty(obj, &apos;anotherVal&apos;, &#123;&#125;); // 抛出 TypeError 错误 Array的扩展扩展的迭代或缩小方法都不会改变原有的数组，只会返回处理后的新数组。 判断方法：添加了静态方法Array.isArray(obj)用于判断obj是否为一个Array对象的实例。 索引方法：添加了两个用于查找指定项索引的方法indexOf()和lastIndexOf()。查找时使用全等（===）进行匹配。 迭代方法：添加了every()、some()、forEach()、map()、filter()方法。 缩小方法：添加了reduce()和reduceRight()方法。 12345678910var arr = [2,9,4,5,3,7,2];console.log(Array.isArray(arr)); //trueconsole.log(arr.indexOf(2)); //0console.log(arr.lastIndexOf(2)); //6console.log(arr.every(function(v,i)&#123; return v &gt; 1 &#125;)); //trueconsole.log(arr.some(function(v,i)&#123; return v&gt;6 &#125;)); //trueconsole.log(arr.map(function(v,i)&#123; return v&gt;5 &#125;)); //[false, true, false, false, false, true, false]console.log(arr.filter(function(v,i)&#123; return v&gt;6 &#125;)); //[9, 7]console.log(arr.reduce(function(pre, v, i)&#123; return res+v &#125;)); //32console.log(arr.reduceRight(function(pre, v, i)&#123; return res*v &#125;)); //15120 Function的扩展 函数中不能出现两个同名的形式参数 不能给函数的caller属性赋值 未指定环境对象而调用函数，this值不会指向window，而是undefined 添加了bind()方法。 规范化了一个函数对象的属性caller，用于指向调用当前函数的函数的引用。 prototype是不可枚举的 Function.prototype.bind 用于改变函数在执行时的this指向 1234567var obj = &#123; name : &quot;alex&quot; &#125;; function func() &#123; console.log(this.name); &#125; var func1 = func.bind(obj)(); // alex String的扩展添加了trim()方法 String.prototype.trim Date的扩展添加了Date.now()、Date.prototype.toJSON()等方法。 123Date.now() 等价于 new Date().getTime()new Date().toJSON(); //&quot;2016-06-29T01:53:15.560Z&quot; RegExp对象在ES3中，使用正则表达式字面量时共享一个RegExp实例，而在ES5中，每次使用正则表达式字面量时都要创建新的RegExp实例，就像使用RegExp构造函数一样。 1/cat/g 等价于 new RegExp(&quot;cat&quot;, &quot;g&quot;); 相关阅读：深入探讨 ECMAScript 规范第五版","raw":null,"content":null,"categories":[{"name":"web开发","slug":"web开发","permalink":"http://www.qiakr.com/categories/web开发/"}],"tags":[{"name":"js","slug":"js","permalink":"http://www.qiakr.com/tags/js/"}]},{"title":"CSS 编码指南","slug":"css-style-guide","date":"2016-05-07T08:03:53.000Z","updated":"2016-05-07T08:12:20.000Z","comments":true,"path":"2016/05/07/css-style-guide/","link":"","permalink":"http://www.qiakr.com/qkfe/2016/05/07/css-style-guide/","excerpt":"前言CSS 作为网页样式的描述语言，在前端开发中有着广泛的应用。本文档的目标是使 CSS 代码风格保持一致，容易被理解和被维护。 虽然本文档是针对 CSS 设计的，但是在使用各种 CSS 的预编译器(如 less、sass、stylus 等)时，适用的部分也应尽量遵循本文档的约定。","keywords":null,"text":"前言CSS 作为网页样式的描述语言，在前端开发中有着广泛的应用。本文档的目标是使 CSS 代码风格保持一致，容易被理解和被维护。 虽然本文档是针对 CSS 设计的，但是在使用各种 CSS 的预编译器(如 less、sass、stylus 等)时，适用的部分也应尽量遵循本文档的约定。 核心规范核心规范规定了洽客前端使用的css框架和基础类，主要包含两个css文件，weui.css 与 style.css。 基础类style.css = 重置类reset.css + 原子类base.css + 组件类component.css; 重置类 包含了对基本类型标签样式的重置 原子类 包含了常用的工具：图像大小，百分比，文本对齐，常用行高，常用字体大小，常用边距，学用字体颜色，边框等。 组件类 包含了图标字体iconfont，弹框，登录等 weui框架见 weui文档说明 页面引用，先引用 style.css 再引入 weui.css 兼容性要求 PC端兼容webkit内核浏览器即可 移动端兼容到Android4.4及以上，iOS7.0及以上版本。 图片使用 小图标：单色图标使用原则 css图标 &gt; iconfont &gt; gif &gt; png 图片使用：优先使用jpg，PS导出质量为高，压缩比率为75%左右。 基本规范 基本规范规定了代码的编写风格，推荐使用下面的规范，以便以团队成员的沟通协作。 代码风格文件 CSS 文件使用无 BOM 的 UTF-8 编码。 解释：win系统自带的记事本新建的txt文件都是带BOM的，带BOM的叫UTF-8+，不带BOM的为UTF-8，部分语言或工具对UTF-8+格式的文档不能正确解析。 缩进 属性展开写法下：以 2 个空格做为层级缩进 推荐采用折叠属性写法，将多个属性写在同一行，属性过多可多行书写 12345.ui-mask &#123; position: fixed; top: 0; right: 0; bottom: 0; left: 0; z-index: 1100; display: none; width: 100%; height: 100%; background-color: rgba(0,0,0,.6); opacity: 0; -webkit-transition: opacity .15s; transition: opacity .15s; &#125; 空格 选择器 与 { 之间必须包含空格。 属性名 与之后的 : 之间不允许包含空格， : 与 属性值 之间必须包含空格。 列表型属性值 书写在单行时，, 后必须跟一个空格。 123456789101112/* good */.ui-tbl&#123; display: table; width: 100%; box-sizing: border-box;&#125;.avatar &#123; font-family: Arial, sans-serif; &#125;/* bad */.ui-tbl&#123;display: table;width: 100%;box-sizing: border-box;&#125;.avatar &#123;font-family: Arial,sans-serif;&#125; 顺序 按功能分组书写，并以 Formatting Model（布局方式、位置） &gt; Box Model（尺寸） &gt; Typographic（文本相关） &gt; Visual（视觉效果） 的顺序书写，以提高代码的可读性。 解释： Formatting Model 相关属性包括：position / top / right / bottom / left / float / display / overflow 等 Box Model 相关属性包括：border / margin / padding / width / height 等 Typographic 相关属性包括：font / line-height / text-align / word-wrap 等 Visual 相关属性包括：background / color / transition / list-style / animation / transform 等 另外，如果包含 content 属性，应放在最前面。 123456.sidebar &#123; position: absolute; top: 50px; left: 0; overflow-x: hidden; width: 200px; padding: 5px; border: 1px solid #ddd; font-size: 14px; line-height: 20px; background: #f5f5f5; color: #333; -webkit-transition: color 1s; -moz-transition: color 1s; transition: color 1s; &#125; 注释 建议使用块注释 /* ... */，注释独占一行。 独立的CSS模块，要添加注释说明 选择器 如无必要，不得为 id、class 选择器添加类型选择器进行限定 解释：在性能和维护性上，都有一定的影响。 12345/* good */#error,.danger-message &#123; font-color: #c00; &#125;/* bad */dialog#error, p.danger-message &#123; font-color: #c00; &#125; 属性选择器中的值必须用双引号包围。 选择器嵌套层级应少于 4 级 尽量使用class选择器 避免直接使用类型选择器 避免空的class 禁用通配符 对需要javascript操作的元素加上ID，ID尽量以驼峰命名法命名。 12345678910111213/* good */ div.vip-wrap ul.vip-list li.vip-item*3.vip-item &#123; ... &#125;/* bad */ div.vip-wrap ul.vip-list li*3.vip-wrap .vip-list li &#123; ... &#125; 属性缩写 在可以使用缩写的情况下，尽量使用属性缩写。 1234567891011/* good */.post &#123; font: 12px/1.5 arial, sans-serif;&#125;/* bad */.post &#123; font-family: arial, sans-serif; font-size: 12px; line-height: 1.5;&#125; 使用 border / margin / padding 等缩写时，应注意隐含值对实际数值的影响，确实需要设置多个方向的值时才使用缩写。解释：border / margin / padding 等缩写会同时设置多个属性的值，容易覆盖不需要覆盖的设定。如某些方向需要继承其他声明的值，则应该分开设置。 命令规则 尽量使用BEM命令规则(Block-Element-Modifie)，但可以适当修改，结合组合式命名更加灵活。 模块名/业务名 - 区域名/元素名 - 状态/颜色 全局组件以 ‘ui-‘ 开头 12345678 /* Msg 弹窗模块 */.ui-msg &#123;&#125;.ui-msg.alert &#123;&#125;.ui-msg.prompt &#123;&#125;.ui-msg.actions &#123;&#125;.ui-msg-hd &#123;&#125;.ui-msg-bd &#123;&#125;.ui-msg-ft &#123;&#125; z-index 在使用relative 或 absolute 定位时，尽量指定固定的z-index的值，值的大小为10倍数，小于999999; 值与单位数值 当数值为 0 - 1 之间的小数时，省略整数部分的 0 123456789/* good */panel &#123; opacity: .8;&#125;/* bad */panel &#123; opacity: 0.8;&#125; 路径 url() 函数中的路径不加引号。 url() 函数中的绝对路径可省去协议名。 123body &#123; background: url(//baidu.com/img/bg.png) no-repeat 0 0;&#125; 长度 长度为 0 时须省略单位。 (也只有长度单位可省) 123456789/* good */body &#123; padding: 0 5px;&#125;/* bad */body &#123; padding: 0px 5px;&#125; 颜色 颜色值可以缩写时，必须使用缩写形式。 123456789/* good */.success &#123; background-color: #aca;&#125;/* bad */.success &#123; background-color: #aaccaa;&#125; 颜色值不允许使用命名色值。 123456789/* good */.success &#123; color: #90ee90;&#125;/* bad */.success &#123; color: lightgreen;&#125; 边框 在定义无边框样式时，使用 0 代替 none。 123456789/* good */.foo &#123; border: 0;&#125;/* bad */.foo &#123; border: none;&#125;","raw":null,"content":null,"categories":[{"name":"web开发","slug":"web开发","permalink":"http://www.qiakr.com/categories/web开发/"}],"tags":[]},{"title":"Javascript 编码指南","slug":"javascript-style-guide","date":"2016-05-07T06:23:18.000Z","updated":"2016-05-07T07:22:14.000Z","comments":true,"path":"2016/05/07/javascript-style-guide/","link":"","permalink":"http://www.qiakr.com/qkfe/2016/05/07/javascript-style-guide/","excerpt":"前言总所周知，javascript 是一种语法极其灵活的语言。变量随时用随时可以声明；语句结束符可以不要；字符串和数字也可以相加；参数多一个少一个也不会报错。没错，当你从 C/C++ 和 Java 严格的语法规定之下，转向 JavaScript 语言，会觉得自由了很多，轻松了很多。 语法松散是 JavaScript 重要的特征。它灵活易懂，给开发人员带来了很多方便，但如果编写过程中不注意，代码的调试成本和维护成本则会无形地增加。JavaScript 编码会随应被直接发送到客户端的浏览器，代码规范不只是代码质量的保证，也影响到产品的长期信誉。 本文档的目标是使 JavaScript 代码风格保持一致，良好的编程风格有助于写出质量更高、错误更少、更易于维护的程序。","keywords":null,"text":"前言总所周知，javascript 是一种语法极其灵活的语言。变量随时用随时可以声明；语句结束符可以不要；字符串和数字也可以相加；参数多一个少一个也不会报错。没错，当你从 C/C++ 和 Java 严格的语法规定之下，转向 JavaScript 语言，会觉得自由了很多，轻松了很多。 语法松散是 JavaScript 重要的特征。它灵活易懂，给开发人员带来了很多方便，但如果编写过程中不注意，代码的调试成本和维护成本则会无形地增加。JavaScript 编码会随应被直接发送到客户端的浏览器，代码规范不只是代码质量的保证，也影响到产品的长期信誉。 本文档的目标是使 JavaScript 代码风格保持一致，良好的编程风格有助于写出质量更高、错误更少、更易于维护的程序。 JavaScript 语言规范12变量 常量 保留字 数组 字符串 函数 块内函数声明 闭包 Array和Object直接量对象原型 True与False 类型分配&amp;强制转换 浮点数精度 命名规范 JavaScript 编码风格12文件编码 分号 逗号 空格 大括号 单引号、双引号 空行 二元和三元操作符 语句块 注释 全局变量 全等 JavaScript 语言规范变量 声明变量必须加上 var 关键字 当你没有写 var, 变量就会暴露在全局上下文中, 这样很可能会和现有变量冲突. 另外, 如果没有加上, 很难明确该变量的作用域是什么, 变量也很可能像在局部作用域中, 很轻易地泄漏到 Document 或者 Window 中, 所以务必用 var 去声明变量. 常量 常量使用大写字符并用下划线分隔，如：PAGE_CONFIG 保留字 不要使用保留字，在IE8中不起作用 1234567891011// goodvar superman = &#123; defaults: &#123; clark: 'kent' &#125;, hidden: true&#125;;// badvar superman = &#123; default: &#123; clark: 'kent' &#125;, private: true&#125;; 数组 添加数组元素时，使用push而不是直接添加 1234567var someStack = [];// goodsomeStack.push('abracadabra');// badsomeStack[someStack.length] = 'abracadabra'; 需要复制数组时，可以使用slice 1234567891011var len = items.length;var itemsCopy = [];var i;// gooditemsCopy = items.slice();// badfor (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i];&#125; 使用slice将类数组对象转为数组 1234function trigger() &#123; var args = Array.prototype.slice.call(arguments); ...&#125; 遍历数组不使用 for in 数组对象可能存在数字以外的属性, 这种情况下 for in 不会得到正确结果. 123456789101112var arr = ['a', 'b', 'c'];arr.other = 'other things'; // 这里仅作演示, 实际中应使用Object类型// 正确的遍历方式for (var i = 0, len = arr.length; i &lt; len; i++) &#123; console.log(i);&#125;// 错误的遍历方式for (i in arr) &#123; console.log(i);&#125; 清空数组使用 .length = 0 字符串 对字符串使用单引号 超过80个字符的字符串应该使用字符串连接符进行跨行（对长字符串过度使用连接符将会影响性能） 12345678910111213// goodvar errorMessage = 'This is a super long error that was thrown because ' + 'of Batman. When you stop to think about how Batman had anything to do ' + 'with this, you would get nowhere fast.';// badvar errorMessage = 'This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.';// badvar errorMessage = 'This is a super long error that was thrown because \\of Batman. When you stop to think about how Batman had anything to do \\with this, you would get nowhere \\fast.'; 使用 join() 来创建字符串 通常写法： 1234567891011function listHtml(items) &#123; var html = '&lt;div class=\"foo\"&gt;'; for (var i = 0; i &lt; items.length; ++i) &#123; if (i &gt; 0) &#123; html += ', '; &#125; html += itemHtml(items[i]); &#125; html += '&lt;/div&gt;'; return html;&#125; 但这样在 IE 下非常慢, 可以用下面的方式 1234567function listHtml(items) &#123; var html = []; for (var i = 0; i &lt; items.length; ++i) &#123; html[i] = itemHtml(items[i]); &#125; return '&lt;div class=\"foo\"&gt;' + html.join(', ') + '&lt;/div&gt;';&#125; 也可以是用数组作为字符串构造器, 然后通过 myArray.join(‘’) 转换成字符串. 不过由于赋值操作快于数组的 push(), 所以尽量使用赋值操作. 函数 不要在非函数块中(if, while, etc)声明函数，尽管浏览器允许你分配函数给一个变量，但坏消息是，不同的浏览器用不同的方式解析它 1234567891011121314// goodvar test;if (currentUser) &#123; test = function test() &#123; console.log('Yup.'); &#125;;&#125;// badif (currentUser) &#123; function test() &#123; console.log('Nope.'); &#125;&#125; 不要命名一个参数为arguments，否则它将优先于传递给每个函数作用域中的arguments对象 123456789// goodfunction yup(name, options, args) &#123; // ...stuff...&#125;// badfunction nope(name, options, arguments) &#123; // ...stuff...&#125; 在作用域顶端对变量赋值，这有助于避免变量声明问题和与声明提升相关的问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// goodfunction() &#123; var name = getName(); test(); console.log('doing stuff..'); //..other stuff.. if (name === 'test') &#123; return false; &#125; return name;&#125;// badfunction() &#123; test(); console.log('doing stuff..'); //..other stuff.. var name = getName(); if (name === 'test') &#123; return false; &#125; return name;&#125;// goodfunction() &#123; if (!arguments.length) &#123; return false; &#125; var name = getName(); return true;&#125;// badfunction() &#123; var name = getName(); if (!arguments.length) &#123; return false; &#125; return true;&#125; 函数声明会提升变量名和函数体 123456789101112131415161718// good function example() &#123; superPower(); // =&gt; Flying function superPower() &#123; console.log('Flying'); &#125;&#125;// badfunction example() &#123; superPower(); // =&gt; TypeError superPower is not a function var superPower = function() &#123; console.log('Flying'); &#125;&#125; 块内函数声明 不要在块内声明函数 123456789// goodif (x) &#123; var foo = function() &#123;&#125;&#125;// badif (x) &#123; function foo() &#123;&#125;&#125; 块内声明函数, 但它不属于 ECMAScript 规范, 各个浏览器糟糕的实现相互不兼容, 有些也与未来 ECMAScript 草案相违背 ECMAScript 只允许在脚本的根语句或函数中声明函数. 如果确实需要在块中定义函数, 建议使用函数表达式来初始化变量: 闭包 小心使用闭包 闭包保留了一个指向它封闭作用域的指针, 所以, 在给 DOM 元素附加闭包时, 很可能会产生循环引用, 进一步导致内存泄漏. 比如下面的代码: 123function foo(element, a, b) &#123; element.onclick = function() &#123; /* uses a and b */ &#125;;&#125; 这里, 即使没有使用 element, 闭包也保留了 element, a 和 b 的引用, . 由于 element 也保留了对闭包的引用, 这就产生了循环引用, 这就不能被 GC 回收. 这种情况下, 可将代码重构为: 1234567function foo(element, a, b) &#123; element.onclick = bar(a, b);&#125;function bar(a, b) &#123; return function() &#123; /* uses a and b */ &#125;&#125; Array 和 Object 直接量 使用 Array 和 Object 语法, 而不使用 Array 和 Object 构造器. 12345678910111213141516//goodvar a = [1, 2, 3];var o2 = &#123; a: 0, b: 1, c: 2, 'strange key': 3&#125;;//badvar a1 = new Array(1, 2, 3);var o2 = new Object();o2.a = 0;o2.b = 1;o2.c = 2;o2['strange key'] = 3; 对象原型 不要修改内置对象的原型，如 Object.prototype 和 Array.prototype 的原型，给添加内置原型方法很容易和其它库冲突或者可能与将来ES升级不兼容。 True 与 False下面的布尔表达式都返回 false: null undefined &#39;&#39; 空字符串 0 数字0 但小心下面的, 可都返回 true: &#39;0&#39; 字符串0 [] 空数组 {} 空对象 如果你想判断是一个变量是否为null/&#39;&#39;/0/false 12345// good if(x)&#123; ... &#125;// badif(x != null)&#123; ... &#125; 还有很多需要注意的地方 以下都为true 1234567891011121314151617Boolean('0') == true'0' != true0 != null0 == []0 == falseBoolean(null) == falsenull != truenull != falseBoolean(undefined) == falseundefined != trueundefined != falseBoolean([]) == true[] != true[] == falseBoolean(&#123;&#125;) == true&#123;&#125; != true&#123;&#125; != false 遍历 Node ListNode lists 是通过给节点迭代器加一个过滤器来实现的. 这表示获取他的属性, 如 length 的时间复杂度为 O(n), 通过 length 来遍历整个列表需要 O(n^2). 1234var paragraphs = document.getElementsByTagName('p');for (var i = 0; i &lt; paragraphs.length; i++) &#123; doSomething(paragraphs[i]);&#125; 这样做会更好: 1234var paragraphs = document.getElementsByTagName('p');for (var i = 0, paragraph; paragraph = paragraphs[i]; i++) &#123; doSomething(paragraph);&#125; 这种方法对所有的 collections 和数组(只要数组不包含 falsy 值) 都适用. 在上面的例子中, 也可以通过 firstChild 和 nextSibling 来遍历孩子节点. 1234var parentNode = document.getElementById('foo');for (var child = parentNode.firstChild; child; child = child.nextSibling) &#123; doSomething(child);&#125; 类型分配&amp;强制转换 执行强制类型转换的语句 12345678910111213// =&gt; this.reviewScore = 9;// goodvar totalScore = this.reviewScore + ' total score';// badvar totalScore = this.reviewScore + '';// goodvar totalScore = '' + this.reviewScore;// badvar totalScore = '' + this.reviewScore + ' total score'; 使用parseInt对Numbers进行转换，并带一个进制作为参数 12345678910111213141516171819var inputValue = '4';// badvar val = new Number(inputValue);// badvar val = +inputValue;// badvar val = inputValue &gt;&gt; 0;// badvar val = parseInt(inputValue);// goodvar val = Number(inputValue);// goodvar val = parseInt(inputValue, 10); 注意： 当使用位运算时，Numbers被视为64位值，但是位运算总是返回32位整型。对于整型值大于32位的进行位运算将导致不可预见的行为。最大的有符号32位整数是2,147,483,647 12345672147483647 &gt;&gt; 0 //=&gt; 21474836472147483648 &gt;&gt; 0 //=&gt; -21474836482147483649 &gt;&gt; 0 //=&gt; -2147483647~~2147483647 //=&gt; 2147483647~~2147483648 //=&gt; -2147483648~~2147483649 //=&gt; -2147483647 浮点数精度使用了IEEE 754 浮点数格式来存储浮点类型的任何编程语言（C/C++/C#/Java 等等）都存在精度丢失问题。 在 C#、Java 中，提供了 Decimal、BigDecimal 封装类来进行相应的处理，才避开了精度丢失。 原生JS并没有提供相应的API, 寻么就会出现以下类似怪异情况： 12340.1 + 0.2 == 0.300000000000000049999999999999999 == 10000000000000000; // true0.05 + 0.2 == 0.25 // true0.05 + 0.9 == 0.95 // false 对于这人问题这里不做展开，只提供解决方案，可使用 math.js 对数据进行运算 详情解释见 玉伯的JavaScript 中小数和大整数的精度丢失 命名规范 避免单字母名称，让名称具有描述性 123456789// badfunction q() &#123; // ...stuff...&#125;// goodfunction query() &#123; // ..stuff..&#125; 当命名对象、函数和实例时使用骆驼拼写法 1234567891011121314// badvar OBJEcttsssss = &#123;&#125;;var this_is_my_object = &#123;&#125;;function c() &#123;&#125;var u = new user(&#123; name: 'Bob Parr'&#125;);// goodvar thisIsMyObject = &#123;&#125;;function thisIsMyFunction() &#123;&#125;var user = new User(&#123; name: 'Bob Parr'&#125;); 当命名构造函数或类名时，使用驼峰式写法 1234567891011121314151617// badfunction user(options) &#123; this.name = options.name;&#125;var bad = new user(&#123; name: 'nope'&#125;);// goodfunction User(options) &#123; this.name = options.name;&#125;var good = new User(&#123; name: 'yup'&#125;); 命名私有属性时使用前置下划线 123456// badthis.__firstName__ = 'Panda';this.firstName_ = 'Panda';// goodthis._firstName = 'Panda'; 保存this引用时使用_this 1234567891011121314151617181920212223// badfunction() &#123; var self = this; return function() &#123; console.log(self); &#125;;&#125;// badfunction() &#123; var that = this; return function() &#123; console.log(that); &#125;;&#125;// goodfunction() &#123; var _this = this; return function() &#123; console.log(_this); &#125;;&#125; JavaScript 编码风格文件编码 JavaScript 文件使用无 BOM 的 UTF-8 编码。 分号 总是以分号结尾 12345678910111213141516171819202122232425262728293031323334// goodvar myMethod = function() &#123; return 42;&#125;;(function() &#123; // Some initialization code wrapped in a function to create a scope for locals.&#125;)();// badvar myMethod = function() &#123; return 42;&#125;(function() &#123; // Some initialization code wrapped in a function to create a scope for locals.&#125;)();// Uncaught TypeError: (intermediate value)(...) is not a function(…)//语句会解释成, 一个函数带一匿名函数作为参数而被调用, 返回42后, 又一次被\"调用\", 这就导致了错误.// good(function() &#123; var name = 'Skywalker'; return name;&#125;)();或;(function() &#123; var name = 'Skywalker'; return name;&#125;)()// bad(function() &#123; var name = 'Skywalker' return name&#125;)() JavaScript 的语句以分号作为结束符, 除非可以非常准确推断某结束位置才会省略分号. 语句中声明了函数/对象/数组直接量, 但 闭括号(&apos;}&apos;或&apos;]&apos;)并不足以表示该语句的结束. 在 JavaScript 中, 只有当语句后的下一个符号是后缀或括号运算符时, 才会认为该语句的结束. 遗漏分号有时会出现很奇怪的结果, 所以确保语句以分号结束. 逗号 一次性申明多个变量或申明一个对象，逗号置尾 123456789101112131415161718192021// goodvar foo = 1, bar = 2, baz = 3;var obj = &#123; foo: 1, bar: 2, baz: 3&#125;;// badvar foo = 1 , bar = 2 , baz = 3;var obj = &#123; foo: 1 , bar: 2 , baz: 3&#125;; 空格 函数名称和条件语句后面不加空格 12345678910111213141516// goodfunction foo() &#123; return \"bar\";&#125;if(true) &#123; //...&#125;// badfunction foo () &#123; return \"bar\";&#125;if (true) &#123; //...&#125; 参数与括号之间无空格 12345678910111213// good function fn(arg1, arg2) &#123;//orif (true) &#123;// badfunction fn( arg1, arg2 ) &#123; // ...&#125;if ( true ) &#123; // ...&#125; 对象字面量冒号后面加空格，前面不加 12345678910111213// good&#123; foo: 1, bar: 2, baz: 3&#125;// bad&#123; foo : 1, bar : 2, baz : 3&#125; 在左大括号之前留一个空格 123456789// goodfunction test() &#123; console.log('test');&#125;// badfunction test()&#123; console.log('test');&#125; 用空白分隔运算符 12345// goodvar x = y + 5;// badvar x=y+5; 使用软制表符设置两个空格 1234567891011121314// badfunction() &#123;∙∙∙∙var name;&#125;// badfunction() &#123;∙var name;&#125;// goodfunction() &#123;∙∙var name;&#125; 当调用很长的方法链时使用缩进，可以强调这行是方法调用，不是新的语句 12345678910111213141516171819202122232425262728293031323334// bad$('#items').find('.selected').highlight().end().find('.open').updateCount();// bad$('#items'). find('.selected'). highlight(). end(). find('.open'). updateCount();// good$('#items') .find('.selected') .highlight() .end() .find('.open') .updateCount();// badvar leds = stage.selectAll('.led').data(data).enter().append('svg:svg').classed('led', true) .attr('width', (radius + margin) * 2).append('svg:g') .attr('transform', 'translate(' + (radius + margin) + ',' + (radius + margin) + ')') .call(tron.led);// goodvar leds = stage.selectAll('.led') .data(data) .enter().append('svg:svg') .classed('led', true) .attr('width', (radius + margin) * 2) .append('svg:g') .attr('transform', 'translate(' + (radius + margin) + ',' + (radius + margin) + ')') .call(tron.led); 大括号 表示区块起首的大括号，不要另起一行。 12345678910// goodreturn &#123; key : value;&#125;;// badreturn&#123; key:value;&#125;; 代码的原意，是要返回一个对象，但实际上返回的是undefined，因为Javascript自动在return语句后面添加了分号。 单引号、双引号 统一使用单引号 1var msg = 'This is some HTML'; 单引号 (&apos;) 优于双引号 (&quot;). 当你创建一个包含 HTML 代码的字符串时就知道它的好处了. 空行 使用空行来划分一组逻辑上相关联的代码片段. 1234567doSomethingTo(x);doSomethingElseTo(x);andThen(x);nowDoSomethingWith(y);andNowWith(z); 二元和三元操作符 操作符始终跟随着前行, 这样就不用顾虑分号的隐式插入问题. 如果一行实在放不下, 还是按照下面的缩进风格来换行. 1234567891011121314151617181920var x = a ? b : c; // All on one line if it will fit.// Indentation +4 is OK.var y = a ? longButSimpleOperandB : longButSimpleOperandC;// Indenting to the line position of the first operand is also OK.var z = a ? moreComplicatedB : moreComplicatedC;// 二元操作符后面的必须是一个完整的执行语句// badvar isShow = true, x1;isShow ? x1=2;//Uncaught SyntaxError: Unexpected token ;(…)// goodvar isShow = true, x1;isShow ? (x1=2); 二元布尔操作符是可短路的, 只有在必要时才会计算到最后一项.&quot;||&quot; 被称作为 default 操作符 123456789101112131415function foo(opt_win) &#123; var win; if (opt_win) &#123; win = opt_win; &#125; else &#123; win = window; &#125; // ...&#125;// 可简化为function foo(opt_win) &#123; var win = opt_win || window; // ...&#125; “&amp;&amp;” 也可简短代码 1234567891011121314151617if (node) &#123; if (node.kids) &#123; if (node.kids[index]) &#123; foo(node.kids[index]); &#125; &#125;&#125;// 可简化为if (node &amp;&amp; node.kids &amp;&amp; node.kids[index]) &#123; foo(node.kids[index]);&#125;//或者var kid = node &amp;&amp; node.kids &amp;&amp; node.kids[index];if (kid) &#123; foo(kid);&#125; 语句块 对于使用if和else的多行语句块，把else和if语句块的右大括号放在同一行 12345678910111213141516// goodif (test) &#123; thing1(); thing2();&#125; else &#123; thing3();&#125;// badif (test) &#123; thing1(); thing2();&#125;else &#123; thing3();&#125; 注释 多行注释使用/* … /，需包含一个描述、所有参数的具体类型和值以及返回值 123456789101112131415161718192021222324252627// good/** * make() returns a new element * based on the passed in tag name * * @param &#123;String&#125; tag * @return &#123;Element&#125; element */function make(tag) &#123; // ...stuff... return element;&#125;// bad// make() returns a new element// based on the passed in tag name//// @param &#123;String&#125; tag// @return &#123;Element&#125; elementfunction make(tag) &#123; // ...stuff... return element;&#125; 单行注释使用//，把单行注释放在语句的上一行，并且在注释之前空一行 123456789101112131415161718// goodfunction getType() &#123; console.log('fetching type...'); // set the default type to 'no type' var type = this._type || 'no type'; return type;&#125;// badfunction getType() &#123; console.log('fetching type...'); // set the default type to 'no type' var type = this._type || 'no type'; return type;&#125; 使用//TODO:给问题解决方案作注释 1234567function Calculator() &#123; // TODO: total should be configurable by an options param this.total = 0; return this;&#125; 全局变量 避免使用全局变量；如果不得不使用，用大写字母表示变量名，比如UPPER_CASE。 == 和 === 尽量使用’===’来进行逻辑等的判断，用’!==’进行逻辑不等的判断 ==作逻辑等判断时，会先进行类型转换后再进行比较。===则不会。因而，==进行的判断结果可能产生偏差。 12345678910111213141516var valueA = \"1\"; var valueB = 1; if ( valueA == valueB) &#123; alert(\"Equal\"); &#125; else &#123; alert(\"Not equal\") &#125; //output: \"Equal\"if ( valueA === valueB) &#123; alert(\"Equal\"); &#125; else &#123; alert(\"Not equal\") &#125; //output: \"Not equal\"","raw":null,"content":null,"categories":[{"name":"web开发","slug":"web开发","permalink":"http://www.qiakr.com/categories/web开发/"}],"tags":[]}]}