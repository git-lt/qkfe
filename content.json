{"meta":{"title":"洽客前端","subtitle":"洽客技术团队 （QKED）","description":"Talk is cheap, Show me the code.","author":"LT","url":"http://www.qiakr.com"},"pages":[{"title":"关于我们","date":"2016-05-07T08:03:53.000Z","updated":"2016-05-07T08:58:44.000Z","comments":true,"path":"about/index.html","permalink":"http://www.qiakr.com/about/index.html","excerpt":"","keywords":null,"text":"洽客（Qiakr）隶属于杭州蚁国科技有限公司 是一家基于移动互联网,为传统零售企业提供创新型服务的公司 我们为线下实体零售商提供创新的零售方式","raw":null,"content":null}],"posts":[{"title":"微商城装修说明文档","slug":"store-decoration-readme","date":"2016-11-08T05:15:52.000Z","updated":"2016-11-08T05:19:37.000Z","comments":true,"path":"2016/11/08/store-decoration-readme/","link":"","permalink":"http://www.qiakr.com/qkfe/2016/11/08/store-decoration-readme/","excerpt":"微商城装修逻辑稍显复杂，这里将部分逻辑整理成文档，以便以后查询修改。","keywords":null,"text":"微商城装修逻辑稍显复杂，这里将部分逻辑整理成文档，以便以后查询修改。 相关文件PC管理平台模板列表页decoration_main.vmdecoration_main.js模板预览模块mod_decorationMods.vmmod_decorationMods.js 模板编辑页decoration_edit.vmdecoration_edit.js模板编辑模块m_decoration.jsmod_decoration.vm 移动端getStoreHomePage.vmgetStoreHomePage.js 模板类型 默认模板 ：所有门店在没有设置模板的情况下使用默认模板 自定义装修：门店自己的装修模板，编辑门店自定义的装修模板，不会影响到其它门店，属于门店唯一 装修模板：商户可以新建模板，保存时都将保存为标准模板，标准模板可以供商户下所有门店或部分门店使用 每个商户有自己的模板仓库，可以添加/编辑/删除模板 业务逻辑 每个门店有一个商户提供的默认模板和一个自定义模板 门店只能编辑自定义模板或选择商户模板库中的装修模板 商户可批量设置门店的商城模板 商户可修改默认模板和装修模板 装修逻辑所有模块12345678910111213m1000：搜索m1001：轮播广告m1002：通栏广告m1003：两栏广告m1004：商品推荐m1005：文本m1006：活动导航m1007：品牌导航m1008：自定义区域m1009：品类导航m1010：自定义分类导航m1011：店招m1012：店铺信息 模板装修提交的数据内容12345678910111213141516[&apos;m1001&apos;:&#123; imgHeight:320, imgs:[], mid:&apos;1001&apos;, //模块ID orderNumer:1, //模块排序值&#125;,&apos;m1002&apos;:&#123; imgUrl:&apos;https://qncdn.qiakr.com/qk_v3/fullcolumn.png&apos;, linkType:&apos;&apos;, linkInfo:&#123;url:&apos;&apos;, id:&apos;&apos;&#125;, //只有当linkType=0或10时，才存储url orderNumber:2, mid:&apos;m1002&apos;&#125;,version: 20 //当前模板的版本] orderNumber 会在提交时，根据模块的位置自动生成version 在用户保存时，自增1，用于记录模板编辑次数，也可以视为模板版本 交互逻辑 创建新模块12345678910111213141516171819202122232425262728290. 拖拽停止时设置拖拽标识为true1. 刷新模块排序值，更新装修配置信息2. 判断是否为拖动创建模块触发（可能是内部拖动排序触发） 是： 获取模块原始id 找到拖动到手机区域的模块 生成新的模块id 随机 根据原始id找到渲染模板和模板默认数据 渲染到预览区，替换刚刚拖动过来的模块图片 隐藏模块遮罩 显示整体遮罩 当前模块隐藏收起和编辑按钮 不是： 提示模块顺序发生了变化，请注意保存！3. 如果是商品推荐模块 是： 将品牌信息 和 分类信息添加到商品推荐模块的配置数据中4. 显示编辑模块，传递id，配置，编辑模板的名称 获取编辑界面id 获取编辑界面的DOM，检查是否存在 是： 使用新的DOM替换以前的DOM 不是： 根据 模板名称 和 数据 渲染至编辑窗口中 初始化编辑界面的组件 根据模块原始id初始化相应界面的组件5. 将是否为拖拽标识设置为false 取消编辑123456781. 获取编辑界面id2. 判断是否保存过，如果没有则移除，如果有，则隐藏 没有： 隐藏整体遮罩 显示模块遮罩 当前模块显示收起和编辑按钮 移除相关的编辑界面和预览中的模块 有： 隐藏整体遮罩 显示模块遮罩 当前模块显示收起和编辑按钮3. 隐藏编辑界面 点击编辑1231. 获取模块ID、编辑模板、数据2. 显示编辑界面3. 隐藏模块遮罩 显示整体遮罩 当前模块隐藏收起和编辑按钮 删除123456789101.获取模块ID、编辑模板、数据2.提示 是否确定删除3.删了装修配置中的数据4.异步更新到后端 成功： 删除预览中的模块 隐藏整体遮罩 显示模块遮罩 判断是否没有模块了，没有则显示 提示模块 失败： 显示报错信息 预览和发布店铺预览和店铺实际的商城首页为同一个地址预览时，地址中有template参数，界面所有链接不可点击 移动端界面渲染文件位置mall/getStoreHomePage.vmjs/mall/getStoreHomePage.js 模板数据加载为了减少页面的加载时间，装修数据、门店信息、品牌、分类等初始数据由后端注入在模板页面中返回，由全局变量 PAGE_CONF 中获取 页面加载完成后，直接调用 renderConfig 方法渲染页面renderConfg 中判断如果有自定义配置则使用自定义配置，如果没有则使用默认配置 (默认配置在当前页面中) 模板渲染循环配置数据，由模块ID，到模块配置 MODULES 中，查找到页面中的编辑模板，由artTemplate 渲染到页面。 商品列表渲染 已知数量的商品列表：直接根据选择的商品ID，异步加载渲染 未知数量的商品列表：将商品加载信息放入一个队列 PRO_LIST 加载触发 第一次渲染完成后，检测页面是否有滚动条，如果没有，则触发一次加载，如果有数据返回则停止加载，监听滚动事件，如果没有，则继续加载一下个请求，直到加载到数据。当最后队列中请求信息为空时，隐藏 loading 显示 查看所有商品 链接，刷新滚动组件。 需求修改示例 需求1：为商品列表模块添加一个按自定义分类展示的功能 到 mod_decoration.vm 中修改模板内容，添加编辑项，搜索 m1004 找到商品模块编辑模板 m_decoration.js中添加数据groupData 至模板 m_decoration.js中添加保存模块时的取值操作 previewEv 查看保存数据，预览界面是否显示正常 查看编辑是否显示正常 修改移动端 getStoreHomePage.vm &amp; getStoreHomePage.js js 的 _render 方法、loadProList 方法、_creatProList 方法中添加对 group 的判断 查看数据返回是否正常 需求2：为商品选择框添加搜索条件，按类目和自定义分类搜索","raw":null,"content":null,"categories":[{"name":"web开发","slug":"web开发","permalink":"http://www.qiakr.com/categories/web开发/"}],"tags":[]},{"title":"pagination组件使用说明","slug":"pagination-reademe","date":"2016-11-07T05:40:52.000Z","updated":"2016-11-07T05:43:00.000Z","comments":true,"path":"2016/11/07/pagination-reademe/","link":"","permalink":"http://www.qiakr.com/qkfe/2016/11/07/pagination-reademe/","excerpt":"jquery.pagination.js 是一款基于bootstrap分页样式的分页插件，具有灵活配置，方便易用的特性。","keywords":null,"text":"jquery.pagination.js 是一款基于bootstrap分页样式的分页插件，具有灵活配置，方便易用的特性。 默认配置参数1234567891011121314151617181920var defaults = &#123; totalData:0, //数据总条数 showData:0, //每页显示的条数 pageCount:9, //总页数,默认为9 current:1, //当前第几页 prevCls:&apos;prev&apos;, //上一页class nextCls:&apos;next&apos;, //下一页class prevContent:&apos;上一页&apos;, //上一页内容 nextContent:&apos;下一页&apos;, //下一页内容 activeCls:&apos;active&apos;, //当前页选中状态 coping:false, //首页和尾页 homePage:&apos;首页&apos;, //首页节点内容 endPage:&apos;末页&apos;, //尾页节点内容 count:3, //当前页前后分页个数 jump:false, //跳转到指定页数 jumpIptCls:&apos;jump-ipt&apos;, //文本框内容 jumpBtnCls:&apos;jump-btn&apos;, //跳转按钮 jumpBtn:&apos;跳转&apos;, //跳转按钮文本 callback:function(currPageNmu)&#123;&#125; //回调(参数：当前页码)&#125;; 初始化 必要参数：pageData 数据总条数 showData 每页显示条数 使用 ul 标签容器，并添加BS组件样式 pagination 123456//HTML&lt;div class=&quot;nav-box&quot;&gt; &lt;ul class=&quot;pagination&quot; id=&quot;p1&quot;&gt;&lt;/ul&gt;&lt;/div&gt;//JS$(&apos;#p1&apos;).pagination(&#123;totalData:80, showData:5&#125;) 效果 显示’…’和’首页末页’页码过多时，显示...，显示 首页和末页123456//HTML&lt;div class=&quot;nav-box&quot;&gt;&lt;ul class=&quot;pagination&quot; id=&quot;p2&quot;&gt;&lt;/ul&gt;&lt;/div&gt;//JS$(&apos;#p2&apos;).pagination(&#123;totalData:100, showData:5, coping:true&#125;) 效果 回调函数API 插件提供一个配置回调和两个实例方法 实例方法在初始化时执行，配置回调在点击页码时触发 123456789101112131415161718//HTML&lt;div class=&quot;nav-box&quot;&gt;&lt;ul class=&quot;pagination&quot; id=&quot;p3&quot;&gt;&lt;/ul&gt;&lt;/div&gt;//HTML&lt;div class=&quot;nav-box&quot;&gt;&lt;ul class=&quot;pagination&quot; id=&quot;p3&quot;&gt;&lt;/ul&gt;&lt;/div&gt;//JS$(&apos;#p3&apos;).pagination(&#123;totalData:100, showData:5, coping:true,callback:function(i)&#123; $(&apos;#logBox&apos;).append(&apos;&lt;p&gt;当前页码为：&apos;+i+&apos;&lt;/p&gt;&apos;);&#125;&#125;, function(api)&#123; $(&apos;#logBox&apos;).append(&apos;&lt;p&gt;*当前页码为：&apos;+api.getCurrent()+&apos;&lt;/p&gt;&apos;); $(&apos;#logBox&apos;).append(&apos;&lt;p&gt;*当前总页数：&apos;+api.getTotalPage()+&apos;&lt;/p&gt;&apos;);&#125;) 效果 CodePen 示例 See the Pen pagination分页示例 by LT (@togglelt) on CodePen.","raw":null,"content":null,"categories":[{"name":"web开发","slug":"web开发","permalink":"http://www.qiakr.com/categories/web开发/"}],"tags":[]},{"title":"uiLoading组件使用说明","slug":"uiLoading-readme","date":"2016-11-07T05:39:00.000Z","updated":"2016-11-07T05:42:23.000Z","comments":true,"path":"2016/11/07/uiLoading-readme/","link":"","permalink":"http://www.qiakr.com/qkfe/2016/11/07/uiLoading-readme/","excerpt":"加载动画在网页设计中是很常见的。用户们都希望网页加载又快又流畅而不是盯着屏幕苦等，而加载动画能够在内容加载完成前给用户视觉反馈，从而能够吸引用户而不让他们直接放弃继续浏览你的网站。","keywords":null,"text":"加载动画在网页设计中是很常见的。用户们都希望网页加载又快又流畅而不是盯着屏幕苦等，而加载动画能够在内容加载完成前给用户视觉反馈，从而能够吸引用户而不让他们直接放弃继续浏览你的网站。 使用CSS3动画的优点 CSS3加载动画比起直接使用动图的好处是它们是易扩展的并且不需要等待加载过程。 CSS3动画无论是什么设备它们都能够清晰，流畅地呈现，并且你可以很容易地去改善它的效果。 在移动端减少网络流量和节约电耗 可以方便修改和操作动画效果 使用CSS3动画的缺点 不同的平台和浏览器有着不同的兼容性问题 复杂的css3动画需要更多的HTML标签且受浏览器性能制约 常见的CSS3 Loading动画 解决的问题uiLoading组件的出现主要为了解决以下问题： 相比于使用GIF，更容易调整大小颜色，动画效果，动画更流畅，无需加载。 不增加额外标签，仅使用容器的伪类:before与:after来实现动画，使用范围更广范 解决按钮重复快速度点击导致异步多次提交的BUG 以jQ插件的方式，调用简单方便 适用场景 Card中的信息需要异步加载显示时 Table列表数据异步加载示 按钮点击有异步请求时 使用方式1234567//Button 按钮$(&apos;#btn1&apos;).uiLoading(&apos;sm&apos;);//调用插件传入参数sm，在button上显示loading动画 $(&apos;#btn1&apos;).uiLoading(&apos;sm&apos;);//再次调用隐藏button上的loading动画//列表或模块卡片上$(&apos;#table1&apos;).uiLoading(&apos;lg&apos;);//调用插件传入参数lg，在table容器上显示较大的loading动画 $(&apos;#table1&apos;).uiLoading(&apos;lg&apos;);//再次调用隐藏table上的loading 如果不传入任何参数，则默认显示较大的loading 按钮Loading效果 列表Loading效果 Codepen 示例See the Pen uiLoading示例 by LT (@togglelt) on CodePen.","raw":null,"content":null,"categories":[{"name":"web开发","slug":"web开发","permalink":"http://www.qiakr.com/categories/web开发/"}],"tags":[]},{"title":"多功能选择对话框使用说明","slug":"power-dialog-readme","date":"2016-11-07T05:32:19.000Z","updated":"2016-11-07T05:34:11.000Z","comments":true,"path":"2016/11/07/power-dialog-readme/","link":"","permalink":"http://www.qiakr.com/qkfe/2016/11/07/power-dialog-readme/","excerpt":"多功能弹出层封装了通用的大数据选择查询逻辑，解决项目中各处需要频繁用到选择品牌、商品、门店、导购的选择对话框的需求。","keywords":null,"text":"多功能弹出层封装了通用的大数据选择查询逻辑，解决项目中各处需要频繁用到选择品牌、商品、门店、导购的选择对话框的需求。 功能 支持选择商品、品牌、门店、商户、导购【通过配置数据源，可选择任何数据】 支持自定义查询表单和数据 支持分页、显示选择结果、显示选择项目数 支持限制选择项目数 文件路径js/admin/mod_powerSelectDia.js 使用示例使用方式类似于 select2.js，返回和接收的标准化数据格式为 [{id:xx, text:xxx}] 具体请参考 js/admin/mod_couponEditDia.js 注意事项 配置 showResult 显示结果为 true 时，要增加对话框的高度60px，以便显示选择结果区域 如果查询表单比较复杂，配置好模板后，可以在配置 shownAfterFn 这个配置中注册一些表单的事件 如果要验证查询表单的输入，可在配置 getSearchPms 中对输入数据做验证，如果验证失败，提示错误，并返回 false 选择商品初始化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263var proSltDia = $.powerSelectDia(&#123; apiGetData: CONF.apiGetProList, title: '选择商品', listDataName: 'stockVoList', itemsStyle: &#123; width: '100%' &#125;, selectMulti: true,//多选 checkboxTpl: '&lt;table class=\"table table-condensed\"&gt;\\ &lt;thead&gt;&lt;tr&gt;&lt;th&gt;选择&lt;/th&gt;&lt;th&gt;款号&lt;/th&gt;&lt;th&gt;商品信息&lt;/th&gt;&lt;th&gt;现售价&lt;/th&gt;&lt;th&gt;吊牌价&lt;/th&gt;&lt;th&gt;总库存&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;\\ &#123;&#123;each data as item i&#125;&#125;\\ &lt;tr&gt;\\ &lt;td&gt;&lt;div class=\"checkbox sltdia-item checkbox-primary m0\"&gt;&lt;input id=\"d-&#123;&#123;item.id&#125;&#125;\" class=\"j-dia-item\" data-id=\"&#123;&#123;item.id&#125;&#125;\" type=\"checkbox\" value=\"&#123;&#123;item.id&#125;&#125;\"&gt;&lt;label for=\"d-&#123;&#123;item.id&#125;&#125;\" title=\"&#123;&#123;item.text&#125;&#125;\"&gt;&lt;/label&gt; &lt;/div&gt;&lt;/td&gt;\\ &lt;td&gt;[&#123;&#123;item.productCode || \"无款号\"&#125;&#125;]&lt;/td&gt;\\ &lt;td&gt;&#123;&#123;item.text | truncate:15&#125;&#125;&lt;/td&gt;\\ &lt;td&gt;￥&#123;&#123;item.minSkuPrice&#125;&#125;-￥&#123;&#123;item.maxSkuPrice&#125;&#125;&lt;/td&gt;\\ &lt;td&gt;￥&#123;&#123;item.marketPrice&#125;&#125;&lt;/td&gt;\\ &lt;td&gt;&#123;&#123;item.count&#125;&#125;&lt;/td&gt;\\ &lt;/tr&gt;\\ &#123;&#123;/each&#125;&#125;\\ &lt;/table&gt;', searchTpl: '&lt;div class=\"form-group\"&gt;&lt;div class=\"input-group\"&gt; &lt;input type=\"text\" class=\"form-control input-sm w150 j-sales-name\" name=\"fuzzyName\" placeholder=\"请输入商品名称或款号\"&gt; &lt;span class=\"input-group-btn\"&gt; &lt;button type=\"button\" class=\"btn btn-primary btn-sm j-dia-search\"&gt;筛选&lt;/button&gt; &lt;/span&gt; &lt;/div&gt; &lt;/div&gt;', getSearchPms: function($searchWrap) &#123; //返回查询数据 var keywords = $.trim($searchWrap.find('[name=\"fuzzyName\"]').val()); if (keywords.length &gt; 80) &#123; toastr.warning('输入信息过长'); return false; &#125; return &#123; fuzzyName: keywords, supplyTypeList: '1_3', status: 0 &#125;; &#125;, getItemsDataFn: function(data) &#123; //返回列表需要的数据，可以自定义需要的数据，但一定要有id和text return data.map(function(v) &#123; return &#123; id: v.product.id, text: v.stock.productName || 'xxx', count: v.stock.count, productCode: v.product.productCode, minSkuPrice: v.minSkuPrice, maxSkuPrice: v.maxSkuPrice, marketPrice: v.stock.marketPrice, &#125;; &#125;) &#125;, okFn: function(chkRes) &#123; if (chkRes.length) &#123; //处理选择结果 &#125; else &#123; toastr.error('请选择需要限制的商品'); return false; &#125; &#125;, cancelFn: function(chkRes) &#123; if (!chkRes.length) &#123; //处理没有选择中任何项的逻辑 &#125; &#125;&#125;); 打开选择框12//chkedData:如果是编辑，则为一个已经选择数组，如果是创建，则不用传或传一个空数组proSltDia.show(chkedData); 选择门店初始化1234567891011121314151617181920212223242526272829303132333435363738394041var storeSltDia = $.powerSelectDia(&#123; apiGetData: CONF.apiGetStoreList, title: &apos;选择门店&apos;, listDataName: &apos;storeVoList&apos;, selectMulti: true, searchTpl: &apos;&lt;div class=&quot;form-group text-right&quot;&gt;&lt;div class=&quot;input-group&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control input-sm w150 j-sales-name&quot; name=&quot;storeName&quot; placeholder=&quot;店铺名称&quot;&gt; &lt;span class=&quot;input-group-btn&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary btn-sm j-dia-search&quot;&gt;筛选&lt;/button&gt; &lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&apos;, getSearchPms: function($searchWrap) &#123; var storeName = $.trim($searchWrap.find(&apos;[name=&quot;storeName&quot;]&apos;).val()); if (storeName.length &gt; 80) &#123; toastr.warning(&apos;输入信息过长&apos;); return false; &#125; return &#123; storeName: storeName, open:0 &#125;; &#125;, getItemsDataFn: function(data) &#123; return data.map(function(v) &#123; return &#123; id: v.store.id, text: v.store.name || &apos;xxx&apos; &#125;; &#125;) &#125;, okFn: function(chkRes) &#123; if (chkRes.length) &#123; //处理选择结果 &#125; else &#123; toastr.error(&apos;请选择需要限制的门店&apos;); return false; &#125; &#125;, cancelFn: function(chkRes) &#123; if(!chkRes.length)&#123; //处理选择为空时的逻辑 &#125; &#125; &#125;); 显示对话框1storeSltDia.show(chkedStoreData) 选择品牌初始化1234567891011121314151617181920212223242526272829303132333435363738394041var brandSltDia = $.powerSelectDia(&#123; apiGetData: CONF.apiGetBrandList, title: &apos;选择品牌&apos;, listDataName: &apos;productBrandList&apos;, selectMulti: true, searchTpl: &apos;&lt;div class=&quot;form-group text-right&quot;&gt;&lt;div class=&quot;input-group&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control input-sm w150 j-sales-name&quot; name=&quot;fuzzyKeyword&quot; placeholder=&quot;品牌名称&quot;&gt; &lt;span class=&quot;input-group-btn&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary btn-sm j-dia-search&quot;&gt;筛选&lt;/button&gt; &lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&apos;, getSearchPms: function($searchWrap) &#123; var keywords = $.trim($searchWrap.find(&apos;[name=&quot;fuzzyKeyword&quot;]&apos;).val()); if (keywords.length &gt; 80) &#123; toastr.warning(&apos;输入信息过长&apos;); return false; &#125; return &#123; fuzzyKeyword: keywords &#125;; &#125;, getItemsDataFn: function(data) &#123; return data.map(function(v) &#123; return &#123; id: v.id, text: v.brandName || &apos;xxx&apos; &#125;; &#125;) &#125;, okFn: function(chkRes) &#123; if (chkRes.length) &#123; //处理选择结果 &#125; else &#123; toastr.error(&apos;请选择需要限制的品牌&apos;); return false; &#125; &#125;, cancelFn: function(chkRes) &#123; if (!chkRes.length) &#123; //处理选择为空的逻辑 &#125; &#125; &#125;); 显示1brandSltDia.show(chkedBrandData) 配置参数说明基本配置【选填】12345678910title: &apos;请选择&apos;, //对话框标题itemsNum: 30, //每页显示的数据条数itemsBoxHeight: 210, //列表项盒子的高度width: 750, //弹出层的宽度height: 300, //弹出层的高度selectMulti: false, //是否多选showResult: false, //是否显示结果okValue: &apos;确定&apos;, //确认按钮文字cancelValue: &apos;取消&apos;, //取消按钮文字itemsStyle: &#123; width: &apos;230px&apos;, display:&apos;inline-block&apos; &#125;, //列表项的样式 数据获取配置【必填】123apiGetData: &apos;&apos;, //【必填】获取数据的urllistDataName: &apos;&apos;, //【必填】返回的数据对象名称getItemsDataFn: $.noop, //【必填】返回列表项目数组，格式：[&#123;id:1, text:&apos;1号店&apos;&#125;,&#123;id: 2, text: &apos;2号店&apos;&#125;] 查询配置【选填】123searchTpl: &apos;&apos;, // 查询表单的模板, 没有则不添加搜索表单searchBtnSlt: &apos;.j-dia-search&apos;, //搜索按钮选择器，便于绑定查询事件getSearchPms: $.noop, //返回查询参数的json对象，就是异步请求的数据, 参数是表单的jQuery对象 列表显示配置【选填】12345678//配置是 单选 时的展示模板radioTpl: &apos;&#123;&#123;each data as item i&#125;&#125;&lt;div class=&quot;radio sltdia-item radio-primary&quot;&gt;&lt;input type=&quot;radio&quot; class=&quot;j-dia-item&quot; name=&quot;radio&quot; id=&quot;d-&#123;&#123;item.id&#125;&#125;&quot; data-id=&quot;&#123;&#123;item.id&#125;&#125;&quot; value=&quot;&#123;&#123;item.id&#125;&#125;&quot;&gt; &lt;label for=&quot;d-&#123;&#123;item.id&#125;&#125;&quot; title=&quot;&#123;&#123;item.text&#125;&#125;&quot;&gt;&#123;&#123;item.text | truncate:9&#125;&#125;&lt;/label&gt;&lt;/div&gt;&#123;&#123;/each&#125;&#125;&apos;,//配置是 多选 时的展示模板checkboxTpl: &apos;&#123;&#123;each data as item i&#125;&#125;&lt;div class=&quot;checkbox sltdia-item checkbox-primary&quot;&gt;&lt;input id=&quot;d-&#123;&#123;item.id&#125;&#125;&quot; class=&quot;j-dia-item&quot; data-id=&quot;&#123;&#123;item.id&#125;&#125;&quot; type=&quot;checkbox&quot; value=&quot;&#123;&#123;item.id&#125;&#125;&quot;&gt; &lt;label for=&quot;d-&#123;&#123;item.id&#125;&#125;&quot; title=&quot;&#123;&#123;item.text&#125;&#125;&quot;&gt;&#123;&#123;item.text | truncate:9&#125;&#125;&lt;/label&gt; &lt;/div&gt;&#123;&#123;/each&#125;&#125;&apos;,//显示 选择结果 的模板checkResTpl: &apos;&#123;&#123;each data as item i&#125;&#125;&lt;span id=&quot;res-&#123;&#123;item.id&#125;&#125;&quot;&gt;&#123;&#123;item.text&#125;&#125;、&lt;/span&gt;&#123;&#123;/each&#125;&#125;&apos;, 回调函数配置 用于返回选择对话框选择的结果，如果 okFn 返回 false，则对话框不会关闭，可用于检查或限制用户选择项的数量123okFn: $.noop, //确定的回调，参数是选择的数据组成的数组cancelFn: $.noop, //取消的回调，参数是选择的数据组成的数组shownAfterFn: $.noop, //对话框显示之后的回调，可以注册一些事件，参数是对话框的jQuery对象 容器模板【选填】12345678910contentTpl: '&lt;div class=\"sltdia-inner\"&gt;\\ &lt;form class=\"sltdia-search form-inline j-dia-searchbox text-right mb10\"&gt;&lt;/form&gt;\\ &lt;div class=\"sltdia-items j-dia-list\"&gt;&lt;/div&gt;\\ &lt;div class=\"sltdia-page\"&gt;\\ &lt;div class=\"text-right\"&gt;\\ &lt;nav&gt;&lt;ul class=\"pagination mt10 j-dia-page\"&gt;&lt;/ul&gt;&lt;/nav&gt;\\ &lt;/div&gt;\\ &lt;/div&gt;\\ &lt;div class=\"sltdia-result\" style=\"max-height:50px; overflow-y:scroll;\"&gt;&lt;/div&gt;\\ &lt;/div&gt;' 方法Methods12dia.show(dataArr)//dataArr用于编辑时，传递已经选择的数据，格式为[&#123;id:1, text:xxx&#125;, &#123;id:2,text:xxx&#125;,...]，如果是单选只传递具有一个元素的数据即可","raw":null,"content":null,"categories":[{"name":"web开发","slug":"web开发","permalink":"http://www.qiakr.com/categories/web开发/"}],"tags":[]},{"title":"洽客官网Node项目说明","slug":"qiakr-node","date":"2016-11-07T02:34:16.000Z","updated":"2016-11-07T03:37:51.000Z","comments":true,"path":"2016/11/07/qiakr-node/","link":"","permalink":"http://www.qiakr.com/qkfe/2016/11/07/qiakr-node/","excerpt":"基于Node + Express的前后端分离项目说明","keywords":null,"text":"基于Node + Express的前后端分离项目说明 目录设计123456789101112131415161718192021222324252627282930.├── app.js - 服务启动主文件├── config.dev.js - 开发环境配置├── config.js - 环境配置├── config.pro.js - 生成环境配置├── db - MongoDB数据库文件├── log4js.config.js - 日志配置├── logs - 日志记录├── package.json├── server - 服务端相关│ ├── api - 数据接口层│ ├── common - 公用工具│ ├── controllers - 控制器│ ├── middlerware - 数据请求中间件│ ├── mock - 接口数据模拟层│ ├── models - MongoDB数据模型层│ ├── service - 数据服务层│ ├── views - 视图层│ │ ├── includes│ │ ├── layout│ │ └── pages│ ├── api.router.js - 数据接口路由│ └── web.router.js - 页面请求路由├── static - 静态资源相关│ ├── home│ ├── home_admin│ ├── home_mobile│ ├── libs│ └── qk.config.js└── test - 测试相关 Views目录说明 pages 目录下按项目目录划分，一个项目一个目录，每个项目可以使用不同的技术框架，由express调用相关的渲染引擎渲染。 static 静态资源目录 按项目资源存放，模块化的项目按页面模块与页面模板目录存放 数据流转 service 层调用 node-zookeeper-dubbo-qk 模块去连接 zookeeper 获取服务器地址，然后通过 socket 连接服务器获取dubbo服务，通过dubbo 服务调用api获取数据，返回给api层，api层对数据进预处理，然后返回给客户端。 后台渲染引擎官网是多页面应用，为了尽可能的提取公用的片段，制作母版页而采用了jade模板，后台管理页面是一个spa应用，采用了artTemplate模板渲染，以便更快的编写模板，免去jade模板的学习成本。 项目中可以使用两种模板： 以.jade 为后缀文件会自动调用 jade 去渲染 以.html为后缀的文件会自动调用 artTemplate 去渲染 新增一个服务 去 service 层注册一个服务，指定接口与调用参数，与java的 dubbo服务一一对应 去 api 层添加数据接口 如果views层有需要该服务提供相关数据时，去 controller 层引入 service层获取数据去渲染页面。 去api.router.js 注册接口路由，对外提供接口服务 编写页面相关逻辑，去 web.router.js 注册页面路由 命名规则api 层 : a + 业务名称controller 层: c + 业务名称service 层: s_ + 业务名称 配置环境拆分不同的环境 端口，数据库，各种服务都有不同的配置，也有相同的配置，分为不同的文件来管理 config.js 不同环境下的公共配置config.dev.js 开发环境下的配置config.pro.js 生产环境下的配置","raw":null,"content":null,"categories":[{"name":"web开发","slug":"web开发","permalink":"http://www.qiakr.com/categories/web开发/"}],"tags":[]},{"title":"VueJS多页项目应用","slug":"vue-multi-page","date":"2016-11-02T16:06:38.000Z","updated":"2016-11-02T16:09:53.000Z","comments":true,"path":"2016/11/03/vue-multi-page/","link":"","permalink":"http://www.qiakr.com/qkfe/2016/11/03/vue-multi-page/","excerpt":"vue.js2.0的多页应用脚手架","keywords":null,"text":"vue.js2.0的多页应用脚手架 必备知识点 Vue.js2.0 中文文档 Vuex 状态管理 中文文档 Vue-router 路由管理 中文文档 Vue-resource 异步请求处理 中文文档 ES6 语法特性 阮一峰教程 ES6常用特性点此查看 Vuex基础介绍点此查看 项目结构项目目录 状态管理目录 主要目录说明 api 目录：集中管理整个应用的api数据请求 filters 目录：注册Vue全局的filter，便于在所有页面中使用 components 目录：存放多个页面共用的Vue组件 modules 目录：管理每个独立的页面（频道） store 目录：管理应用的全局状态 页面划分 modules 下每一个目录是一个独立的SPA页面的相关资源，把项目划分为多个频道，一个SPA页面为一个频道，每个频道下的相关子页面放置于views目录中 好处是不同的频道可由不同的人开发，互不干扰，技术方案也可以不同，比如可不用vue-router、vuex等相关插件，结合jQuery或者其它路由管理模块使用，只把vue做为页面资源模块加载和容器也是可以的。 路由配置使用懒加载的方式加载路由对应的组件1234567891011121314151617181920212223const SupplierData = resolve =&gt; require(['./views/supplier-data.vue'], resolve)const SupplierList = resolve =&gt; require(['./views/supplier-list.vue'], resolve)const SupplierSetup = resolve =&gt; require(['./views/supplier-setup.vue'], resolve)export default [ &#123; path: '/', meta:'首页', redirect: '/data', &#125;&#123; path: '/data', meta:'商户数据', component: SupplierData, &#125;,&#123; path: '/list', meta: '商户列表', component: SupplierList, &#125;,&#123; path: '/setup', meta: '商户设置', component: SupplierSetup, &#125;]; 给路由注册全局的钩子，用于显示loading指示页面的切换状态 12345678router.beforeEach((to, from , next) =&gt; &#123; store.commit('UPDATE_LOADING', &#123;loading: true &#125;) next()&#125;)router.afterEach(route =&gt; &#123; store.commit('UPDATE_LOADING', &#123;loading: false &#125;)&#125;) Vuex数据流转 使用Vuex集中管理页面组件的状态，在编写组件时，将 store 中的 Getters/State/Mutaions/Actions 映射至组件，组件的事件操作触发Actions或Mutations来更新所绑定的状态数据，从而触发UI的更新。 getters 返回 store 中computed 属性 state 返回 store 中状态属性 data mutations 返回唯一同步改变state的方法 actions 返回异步获取数据提交commit更新state的方法 RESTful API设计REST(Representational State Transfer) 的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。 特点 每一个URI代表一种资源； 客户端和服务器之间，传递这种资源的某种表现层； 客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。 HTTP动词使用 HTTP动词 来区别对数据的操作： GET（SELECT）：从服务器取出资源（一项或多项）。 POST（CREATE）：在服务器新建一个资源。 PUT（UPDATE）：在服务器更新资源（客户端提供改变后的 完整资源）。 PATCH（UPDATE）：在服务器更新资源（客户端提供改变的 属性）。 DELETE（DELETE）：从服务器删除资源。 示例一级APIGET /users - 获取用户列表GET /users/1 - 获取 Id 为 1 的用户POST /users - 创建一个用户PUT /users/1 - 替换 Id 为 1 的用户PATCH /users/1 - 修改 Id 为 1 的用户DELETE /users/1 - 删除 Id 为 1 的用户 多级APIGET /users/1/products - 获取 Id 为 1 用户下的产品列表GET /users/1/products/2 - 获取 Id 为 1 用户下 Id 为 2 的产品POST /users/1/products - 在 Id 为 1 用户下，创建一个产品PUT /users/1/products/2 - 在 Id 为 1 用户下，替换 Id 为 2 的产品PATCH /users/1/products/2 - 修改 Id 为 1 的用户下 Id 为 2 的产品DELETE /users/1/products/2 - 删除 Id 为 1 的用户下 Id 为 2 的产品 注册与登录的API设计登录/登出对应的服务端资源应该是session操作，所以相关api应该如下： GET /session 获取会话信息 PUT /session 更新会话信息 (心跳) POST /session 创建新的会话（登入） DELETE /session 销毁当前会话（登出） 注册对应的资源是user GET /user/:id 获取id用户的信息 PUT /user/:id 更新id用户的信息 POST /user 创建新的用户（注册） DELETE /user/:id 删除id用户（注销） 结合Vue-resource使用 vue-resource 对API进行集中式管理 vue-resource 对应restful的操作123456get: &#123;method: 'GET'&#125;,save: &#123;method: 'POST'&#125;,query: &#123;method: 'GET'&#125;,update: &#123;method: 'PUT'&#125;,remove: &#123;method: 'DELETE'&#125;,delete: &#123;method: 'DELETE'&#125; 1234567891011//api.jsimport Vue from 'vue'import VueResource from 'vue-resource'Vue.use(VueResource)Vue.http.options.emulateJSON = true;export const apiMenus = Vue.resource('/api/menus')export const apiSession = Vue.resource('/api/session&#123;/id&#125;')export const apiUser = Vue.resource('/api/user&#123;/id&#125;') 在actions中导入api模块进行异步请求操作 123456import &#123; apiSession, apiMenus &#125; from '../../../api/'apiSession.save(&#123;uName:'', password: ''&#125;).then().catch()apiSession.get().then().catch()apiSession.put(&#123;state: 1&#125;).then().catch()apiSession.delete().then().catch()","raw":null,"content":null,"categories":[{"name":"web开发","slug":"web开发","permalink":"http://www.qiakr.com/categories/web开发/"}],"tags":[{"name":"js","slug":"js","permalink":"http://www.qiakr.com/tags/js/"}]},{"title":"Vuex基础入门","slug":"vuex-base","date":"2016-11-02T07:46:24.000Z","updated":"2017-02-12T14:46:01.000Z","comments":true,"path":"2016/11/02/vuex-base/","link":"","permalink":"http://www.qiakr.com/qkfe/2016/11/02/vuex-base/","excerpt":"多组件共用相同的状态时，在深层嵌套组件间传递属性过于冗长，并且不能简单地在同级别的组件间传递，直接引用 父/子 实例，又或是通过事件来修改和同步多份状态副本。这样的模型是脆弱的，代码很快会变得不可维护。理解Vue组件之间的数据传递关系到应用的健壮性和可维护性。","keywords":null,"text":"多组件共用相同的状态时，在深层嵌套组件间传递属性过于冗长，并且不能简单地在同级别的组件间传递，直接引用 父/子 实例，又或是通过事件来修改和同步多份状态副本。这样的模型是脆弱的，代码很快会变得不可维护。理解Vue组件之间的数据传递关系到应用的健壮性和可维护性。 通信原则 Props Down Events Up父组件向子组件传递数据使用 props子组件向父组件传递数据使用 event 单向数据流组件实例的作用域是孤立的不应该在子组件的模板内直接引用父组件的数据 prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是不会反过来。这是为了防止子组件无意修改了父组件的状态——这会让应用的数据流难以理解。 12345678910//在父组件中使用props传递给子组件&lt;child message=\"hello!\"&gt;&lt;/child&gt;//定义子组件Vue.component('child', &#123; // 声明 props props: ['message'], // props可以像data一样，使用this.message访问 template: '&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'&#125;) 自定义事件在父组件中使用指令 v-on:cusEvent 绑定自定义事件在子组件中使用指令 v-on:click=”this.$emit(‘cusEvent’, args1, args2 )” 来触发父组件的事件，并传递参数 123456789101112131415161718//父组件绑定自定义事件increment&lt;button-counter v-on:increment=\"incrementTotal\"&gt;&lt;/button-counter&gt;//子组件通过this.$emit('increment')触发父组件绑定的事件Vue.component('button-counter', &#123; template: '&lt;button v-on:click=\"increment\"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;', data: function () &#123; return &#123; counter: 0 &#125; &#125;, methods: &#123; increment: function () &#123; this.counter += 1 this.$emit('increment') &#125; &#125;,&#125;) 全局事件总线(global event bus)在父组件中利用vue实例的$on注册一个事件，在子组件中使用vue实例的$emit来触发父组件中的事件 123456789var bus = new Vue()//父组件中注册一个自定义事件 id-selectedbus.$on('id-selected', function (id) &#123; // ...&#125;)//在子组件中触发事件id-selected并传递数据idbus.$emit('id-selected', 1) 避免使用 vm.$parent / vm.$root / vm.$children 状态管理器 Vuex一个专门为 Vue.js 应用设计的 状态管理模型 + 库为应用内的所有组件提供集中式存储服务，其中的规则确保状态只能按预期方式 在 vue 应用中，vuex 就充当了数据提供者的角色，vue 则只需要关注页面的展示与交互。 state (状态)，驱动我们应用的真实的源；view (视图)，对应着 状态 的声明式映射；actions (动作)，用户在 视图 上的输入引起状态的更改的可能方式。 Vuex 核心概念应用场景页面状态数据：路由、加载状态、异步数据、开关、分页页码、表单数据 state （ store 的 data）存放整个应用状态，作为应用的唯一数据源驱动UI视图的更新尽量初始化详细的state数据 组件中直接访问12345computed: &#123; count () &#123; return this.$store.state.count &#125;&#125; 使用工具函数 mapSate 访问用于将独立的state数据映射到组件的 computed 属性中 123456789101112131415import &#123; mapState &#125; from 'vuex'export default &#123; // ... computed: mapState(&#123; // 箭头函数可以让代码非常简洁 count: state =&gt; state.count, // 传入字符串 'count' 等同于 `state =&gt; state.count` countAlias: 'count', // 想访问局部状态，就必须借助于一个普通函数，函数中使用 `this` 获取局部状态 countPlusLocalState (state) &#123; return state.count + this.localCount &#125; &#125;) &#125; actions （ store 的 methods）不改变状态，只提交(commit) mutation。可以包含任意异步操作。 组件中直接访问123mounted()&#123; this.$store.dispatch('getUserData')&#125; 工具函数 mapActions 访问用于将action方法映射到组件的 methods 中 123456789101112import &#123; mapActions &#125; from 'vuex'export default &#123; // ... methods: &#123; ...mapActions([ 'increment' // 映射 this.increment() 到 this.$store.dispatch('increment') ]), ...mapActions(&#123; add: 'increment' // map this.add() to this.$store.dispatch('increment') &#125;) &#125;&#125; mutations （ store 的 methods）定义了 同步 改变 state 的唯一方法在store中，实际改变 状态(state) 的唯一方式是通过 提交(commit) 一个 mutation 组件中使用12345methods:&#123; add()&#123; this.$store.commit('ADD_NUMBER',&#123;num: 1&#125;) &#125;&#125; 使用工具函数 mapMutations将mutation映射到组件的 methods 中 123456789import &#123; mapMutations &#125; from 'vuex'export default &#123; // ... methods: &#123; ...mapMutations(&#123; add: 'increment' // 映射 this.add() 到 this.$store.commit('increment') &#125;) &#125;&#125; getters （ store 的 computed）和计算属性功能相同，基于多个状态生成新的状态 组件中使用12345computed: &#123; doneTodosCount () &#123; return this.$store.getters.doneTodosCount &#125;&#125; 工具函数 mapGetters用于将getter属性映射到组件的computed中 123456789101112import &#123; mapGetters &#125; from 'vuex'export default &#123; // ... computed: &#123; // 使用对象扩展操作符把 getter 混入到 computed 中 ...mapGetters([ 'doneTodosCount', 'anotherGetter', // ... ]) &#125;&#125; 组件仍然可以具有局部状态 使用 Vuex 并不意味你应该把 所有 状态都放在 Vuex 中去管理。尽管把更多的状态放到 Vuex 管理，会让状态变化变得更加清晰和可调试，但有时也能使代码变得冗余和不直观。如果某部分状态严格属于一个单独的组件，那就只把这部分状态作为局部状态就好了。 理解：状态分为 应用级状态 和 组件级状态原子类组件，尽量由父组件传递状态数据使用当组件状态不影响父组件和其它同级组件时，可做为组件内部状态页面级的数据应该做为应用级状态管理 Redux 的作者有一句话说的不错(redux与vuex都是在flux模式上的改进)：原文：Flux libraries are like glasses: you’ll know when you need them.译文：Flux 库就像眼镜：当你需要它们的时候你会懂的。","raw":null,"content":null,"categories":[{"name":"web开发","slug":"web开发","permalink":"http://www.qiakr.com/categories/web开发/"}],"tags":[{"name":"js","slug":"js","permalink":"http://www.qiakr.com/tags/js/"}]},{"title":"ES6常用特性","slug":"ES6-base","date":"2016-11-02T07:44:21.000Z","updated":"2016-11-02T16:17:52.000Z","comments":true,"path":"2016/11/02/ES6-base/","link":"","permalink":"http://www.qiakr.com/qkfe/2016/11/02/ES6-base/","excerpt":"这里列出在项目中常用的ES6相关特性，以便更快的理解和应用ES6。","keywords":null,"text":"这里列出在项目中常用的ES6相关特性，以便更快的理解和应用ES6。 常用特性 作用域控制 let、const 模板字符串 语法糖 - 箭头函数 解构 类与模块 Promise let &amp; const const 不可重新赋值的值 (常量、配置项以及引用的组件) let 使用let声明的变量只在语句块内有效 let 的使用场景相对较少的，我们只会在 loop(for，while 循环)及少量必须重定义的变量上用到他 let 的使用场景12345678910111213// 函数体内的变量function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125;// for循环的初始量for (let i = 0; i &lt; buttons.length; i++) &#123; // ...&#125; const 由于不可以重新赋值的特性，所以可以做更多语法静态分析方面的优化，从而有更高的执行效率。 const 的使用场景1234567891011// 定义常量const REG_GET_INPUT = /^\\d&#123;1,3&#125;$/;// 定义配置项const config = &#123; isDev : false, pubDir: './admin/'&#125;// 引入 gulpconst gulp = require('gulp'); 模板字符串 Template Strings增强版的字符串，用反引号（`）标识，支持变量注入与多行文本 1234567891011121314151617181920212223242526272829//1. 注入变量与方法const start = 'hi all';const getName = () =&gt; &#123; return 'jelly';&#125;;const conf = &#123; fav: 'Coding'&#125;;const msg = `$&#123;start&#125;, my name is $&#123;getName()&#125;, $&#123;conf.fav&#125; is my favourite`;// 2. 与引号混用const wantToSay = `I'm a \"tbfed\"`;// 3. 支持多行文本const slogan = `I have a dream today!`;// 4. 比较适合写HTMLconst resultTpl = ` &lt;section&gt; &lt;div&gt;...&lt;/div&gt; &lt;/section&gt;`; 箭头函数 Arrow Function使用箭头(=&gt;)进行定义的函数，属于匿名函数（Lambda）一类 箭头函数没有独立执行上下文（ this ），所以其内部引用 this 对象会直接访问父级。 1234567891011121314151617181920212223242526272829303132// 完整写法const getOptions = (name, key) =&gt; &#123; ...&#125;// 省略参数括号const getOptions = key =&gt; &#123; ... &#125;// 省略参数和方法体括号const getOptions = key =&gt; console.log(key);// 无参数或方法体，括号不能省略const noop = () =&gt; &#123;&#125;;// 应用示例let names = [ 'Will', 'Jack', 'Peter', 'Steve', 'John', 'Hugo', 'Mike' ]let newSet = names .map((name, index) =&gt; &#123; return &#123; id: index, name: name &#125; &#125;) .filter(man =&gt; man.id % 2 == 0) .map(man =&gt; [man.name]) .reduce((a, b) =&gt; a.concat(b))console.log(newSet) //=&gt; [ 'Will', 'Peter', 'John', 'Mike' ] 解构 Destructuring用于分解方法的参数、数组、对象中的变量 12345678910111213const bookSet = ['UED', 'TB fed', 'Not find'];const bookCollection = () =&gt; &#123; return &#123;book1: 'UED', book2: 'TB fed'&#125;;&#125;;// 1. 解构也可以设置默认值const &#123;book1, book3 = 'Not find'&#125; = bookCollection();// 2. 解构数组时候是可以跳过其中某几项的const [book1,,book3] = bookSet; // book1 = 'UED', book3 = 'Not find'// 3. 解构可以取到指定对象的任何属性，包括它包含的方法const &#123;length: setLength&#125; = bookSet; // setLength = 3 Rest运算符（解构赋值）/ Spread扩展运算符（…）12345678910111213141516// 1. rest 得到的是一个真正的数组而不是一个伪数组const getOptions = function(...args)&#123; console.log(args.join); // function&#125;;// 2. rest 可以配合箭头函数使用，达到取得所有参数的目的const getOptions = (...args) =&gt; &#123; console.log(args); // array&#125;;// 3. spread 可以用于解构时，聚合所得的值const [opt1, ...opts] = ['one', 'two', 'three', 'four'];// 4. spread 可以用于数组定义const opts = ['one', 'two', 'three', 'four'];const config = ['other', ...opts]; 类与模块 Class &amp; Modules class 定义一个类12345678910111213141516171819202122232425262728//定义类class Point &#123; //构造函数 constructor(x, y) &#123; //实例属性 this.x = x; this.y = y; &#125; //get和set用于对实例属性自定义存取行为 get prop() &#123; return 'getter'; &#125; set prop(value) &#123; console.log('setter: '+value); &#125; //实例方法 toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125; //静态方法 static classMethod() &#123; return 'hello'; &#125; //静态属性 static get HuaChen()&#123; return 'jelly'; &#125;&#125; 使用 extend 关键字实现类的继承 12345678910class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); // 调用父类的constructor(x, y), super必须调用 this.color = color; &#125; toString() &#123; return this.color + ' ' + super.toString(); // 调用父类的toString() &#125;&#125; import 模块引入的方式 12345678910import name from \"module-name\"import * as name from \"module-name\"import &#123; member &#125; from \"module-name\"import &#123; member as alias &#125; from \"module-name\"import &#123; member1 , member2 &#125; from \"module-name\"import &#123; member1 , member2 as alias2 , [...] &#125; from \"module-name\"import defaultMember, &#123; member [ , [...] ] &#125; from \"module-name\"import defaultMember, * as alias from \"module-name\"import defaultMember from \"module-name\"import \"module-name\" export 模块导出或对外提供接口的方式 12345678910111213141516171819202122232425262728293031export var firstName = 'Michael';export var lastName = 'Jackson';export var year = 1958;// 等同于var firstName = 'Michael';var lastName = 'Jackson';var year = 1958;export &#123;firstName, lastName, year&#125;;// 有defautl 与 无default// 输出export default function crc32() &#123; // ...&#125;// 输入import crc32 from 'crc32';// 输出export function crc32() &#123; // ...&#125;;// 输入import &#123;crc32&#125; from 'crc32';// 设置别名function add(x, y) &#123; return x * y;&#125;export &#123;add as default&#125;; export default命令其实只是输出一个叫做 default 的变量，所以它后面不能跟变量声明语句。 123456789// 正确export var a = 1;// 正确var a = 1;export default a;// 错误export default var a = 1; PromisePromise 为异步编程提供统一的解决方案，比传统的回调和事件更加合理有效。 12345678910111213141516171819202122232425262728// 1. 多个异步任务同时执行用 Promise.all，顺序执行使用链式调用// Promise.allPromise .all([jsBuildPromise, cssBuildPromise]) .then(() =&gt; &#123; ... &#125;);// 2. Promise 的链式调用需要每一个过程返回一个 Promise 对象才能保证顺序执行gitPromise .then(() =&gt; git.add()) // 正确，箭头函数简写 .then(() =&gt; &#123; git.commit(); // 错误，函数返回 undefined，会立即执行下一过程 &#125;) .then(() =&gt; &#123; return git.log(); // 正确 &#125;);// 3. Promise 需要调用 catch 方法来捕获错误，而且过程内的错误不会阻塞后续代码执行new Promise(() =&gt; &#123; f; // not define error !&#125;).catch((err) =&gt; &#123; console.log(err) // show 'f is not define'&#125;);console.log('error test'); // 此行可以被正常执行","raw":null,"content":null,"categories":[{"name":"web开发","slug":"web开发","permalink":"http://www.qiakr.com/categories/web开发/"}],"tags":[{"name":"js","slug":"js","permalink":"http://www.qiakr.com/tags/js/"}]},{"title":"基于 koa + gulp 的前端工程构建工具","slug":"velocity-koa-gulp","date":"2016-09-01T02:57:50.000Z","updated":"2016-09-01T03:40:55.000Z","comments":true,"path":"2016/09/01/velocity-koa-gulp/","link":"","permalink":"http://www.qiakr.com/qkfe/2016/09/01/velocity-koa-gulp/","excerpt":"该工具用于移动端和微商城相关H5页面，用于搭建简易的前端web服务，mock服务，优化velocity页面中嵌入的css与js，并提供实时编辑预览功能。","keywords":null,"text":"该工具用于移动端和微商城相关H5页面，用于搭建简易的前端web服务，mock服务，优化velocity页面中嵌入的css与js，并提供实时编辑预览功能。 适用场景 使用velocity模板的H5多页项目 还没有实现组件化，css与js是嵌入在页面中的活动页面或简单页面 特点 对于现有的Java项目目录结构没有侵入性 通过node版的velocity模板引擎生成独立的前端web服务 对多页面中内嵌的css与js进行优化 自动生成对应的css雪碧图 使用mock服务模拟数据请求 基于livereload的实时刷新预览 监听文件变动，自动构建新的版 解决方案此项目主要针对移动端多页面的优化，项目中的H5页面，特点是引用一个公共的css，js引用cdn上的公共js，而与页面相关的css与js直接嵌入在页面中（减少请求数量） 在没有打包构建工具的情况下 css3相关新特性需要手动添加各版本和浏览器前缀 雪碧图、base64图片需要手动生成，然后再应用到css css并没有做相关优化压缩处理 js没有做语法检查和优化压缩 使用velocity模板强依赖后端java环境 不能实时编辑 实时预览 构建流程初始化 读取xx.vm页面 提取内嵌的CSS、JS 合并css、js，去掉多余的标签，只保留最后一个 根据css提取雪碧图，压缩雪碧图，生成base64图片，生成新的css，重新嵌入到xx.vm中 处理css、js 替换 替换xx.vm中的css、js 压缩xx.vm 发布到相关目录 启动livereload监听服务 gulp 任务列表 需要注意的问题在build:init之后，调用生成雪碧图的插件生成的css不一定适用，通常背景图片在使用REM做定位时，不同的屏幕宽度下，图片会错位，所以应将背景图定位改成父类相对定位，添加伪类绝对定位，并放大10倍或100倍，然后再使用css3缩放属性缩小相应的倍数，以提高背景图定位的精确度。具体参考：移动端web app自适应布局探索与总结","raw":null,"content":null,"categories":[{"name":"web开发","slug":"web开发","permalink":"http://www.qiakr.com/categories/web开发/"}],"tags":[]},{"title":"CSS实现垂直水平居中","slug":"css-center","date":"2016-08-21T03:20:51.000Z","updated":"2016-09-01T03:35:53.000Z","comments":true,"path":"2016/08/21/css-center/","link":"","permalink":"http://www.qiakr.com/qkfe/2016/08/21/css-center/","excerpt":"水平垂直居中显示，这种展示用CSS来实现又是比较棘手的一件事，但有各种hack的方式可以实现，各有优缺点，兼容性也各有不同，这里举例几种常见的实现方式。","keywords":null,"text":"水平垂直居中显示，这种展示用CSS来实现又是比较棘手的一件事，但有各种hack的方式可以实现，各有优缺点，兼容性也各有不同，这里举例几种常见的实现方式。 1、绝对定位居中（子元素需设置宽高）内容块的父容器：position:relative;子元素：position: absolute;top: 0;left: 0;bottom: 0;right: 0;margin:auto; （必须设置高度） 原理：元素在过度受限情况下，将margin设置为auto，浏览器会重算margin的值，过度受限指的是同时设置top/bottom与height或者left/right与width。 2、绝对定位配合margin（子元素需设置宽高） 原理：top：50%元素上边界位于包含框中点，设置负外边界使得元素垂直中心与包含框中心重合； 第一种 1234567891011121314151617&lt;style&gt; .one&#123; border: 1px solid red; width: 200px;height: 200px; position: relative; &#125; .two&#123; background: red; width: 100px;height: 100px position: absolute;left: 50%;top:50%; margin: -50px 0 0 -50px; （margin设置百分比是相当于自身的高度与宽度） &#125; &lt;/style&gt; &lt;div class=\"one\"&gt; &lt;div class=\"two\"&gt;&lt;/div&gt; &lt;/div&gt; 第二种 1234567891011121314151617181920212223&lt;style&gt; .one&#123; border: 1px solid red; width: 300px;height: 300px; position: relative; &#125; .two&#123; position:absolute; top:50%; left:0; right:0; margin:auto; margin-top:-100px; （margin设置百分比是相当于自身的高度与宽度） width:200px; height:200px; background: red; &#125;&lt;/style&gt;&lt;body&gt;&lt;div class=\"one\"&gt; &lt;div class=\"two\"&gt;&lt;/div&gt;&lt;/div&gt; 3、table-cell方式（子元素不需设置宽高）父容器：display:table-cell;text-align:center;vertical-align:middle;（设置宽高）子元素：display:inline-block;vertical-align:middle; 原理：利用表格布局的特点，vertical-align设置为middle;单元格中的内容与所在行中间对齐 123456789101112131415&lt;style&gt; .one&#123; border: 1px solid red; width: 200px;height: 200px; display:table-cell;vertical-align:middle;text-align: center; &#125; .two&#123; background: red; (1)display:inline-block;(用此方法向上偏差2px) (2)margin:auto（垂直水平居中） &#125;&lt;/style&gt;&lt;div class=\"one\"&gt; &lt;div class=\"two\"&gt;11111111111&lt;/div&gt;&lt;/div&gt; 4、通过添加空span标签使图片居中（子元素需设置宽高）父容器：text-align: center; &lt;span&gt;display: inline-block; 将行内元素改变为行内块元素显示width: 1px; 实现ＩＥ下可读效果height: 100%; 使用元素高度和图片容器高度一样vertical-align: middle; 垂直对齐图片：vertical-align: middle; 1234567891011121314151617&lt;style&gt; .one&#123; border: 1px solid red; width: 200px;height: 200px; text-align: center; &#125; span&#123; display: inline-block; width: 1px; height: 100%; vertical-align: middle; &#125;&lt;/style&gt;&lt;div class=\"one\"&gt; &lt;span&gt;&lt;/span&gt; &lt;img src=\"../img/jian.png\" alt=\"\"&gt;&lt;/div&gt; 5、外边距margin取负数，大小为width/height（不使用box-sizing: border-box时包括padding，）的一半，再加上top: 50%; left: 50%;（子元素需设置宽高）。123456789101112131415161718192021&lt;style&gt; .one&#123; border: 1px solid red; width: 200px;height: 200px; position: relative; &#125; .two&#123; background: red; width: 30px; height: 20px; padding: 20px; position: absolute; top: 50%; left: 50%; margin-left: -35px; /* (width + padding)/2 */ margin-top: -30px; /* (height + padding)/2 */ &#125;&lt;/style&gt;&lt;div class=\"one\"&gt; &lt;span&gt;&lt;/span&gt; &lt;div class=\"two\"&gt;&lt;/div&gt;&lt;/div&gt; 6、内容定义transform:translate(-50%,-50%),并且加上top：50%；left：50%。（子元素需设置宽高）12345678910111213141516171819202122&lt;style&gt; .one&#123; border: 1px solid red; width: 200px;height: 200px; position: relative; &#125; .two&#123; background: red; width: 50%; height: 30%; margin: auto; position: absolute; top: 50%; left: 50%; -webkit-transform: translate(-50%,-50%); -ms-transform: translate(-50%,-50%); transform: translate(-50%,-50%); &#125;&lt;/style&gt;&lt;div class=\"one\"&gt; &lt;span&gt;&lt;/span&gt; &lt;div class=\"two\"&gt;&lt;/div&gt;&lt;/div&gt; 7、增加额外子元素设置margin-bottom为内容元素的高度+padding的一半。（不能实现水平垂直居中，仅垂直居中） 原理与2方法类似，floater的下边界是包含框的中心线，负下外边界保证center的中心线与包含框中心线重合 123456789101112131415161718192021&lt;style&gt; .one&#123; border: 1px solid red; width: 200px;height: 200px; &#125; .floater&#123; float: left; height: 50%; width: 100%; margin-bottom: -10%; &#125; .two&#123; clear: both; height: 20%; background: red; &#125;&lt;/style&gt;&lt;div class=\"one\"&gt; &lt;div class=\"floater\"&gt;&lt;/div&gt; &lt;div class=\"two\"&gt;&lt;/div&gt;&lt;/div&gt; 8、inline-block方式（子元素不需设置宽高） 原理：为同一行的inline-block元素设置vertical-align：middle，该行内的inline-block元素会按照元素的垂直中心线对齐。 123456789101112131415161718192021&lt;style&gt; .one&#123; border: 1px solid red; width: 300px;height: 300px; text-align: center; &#125; .one:after&#123; content: ''; display: inline-block; vertical-align: middle; height: 100%; &#125; .two&#123; background: red; display:inline-block; vertical-align:middle; &#125;&lt;/style&gt;&lt;div class=\"one\"&gt; &lt;div class=\"two\"&gt;11111111111111111111&lt;/div&gt;&lt;/div&gt; 9、弹性盒式布局（子元素不需设置宽高）CSS弹性盒 123456789101112131415161718192021222324&lt;style&gt; (1) .one&#123; border: 1px solid red; width: 300px;height: 300px; display: flex; align-items: center; justify-content: center; &#125; .two&#123; background: red; &#125; (2) .one&#123; border: 1px solid red; width: 300px;height: 300px; display: flex; &#125; .two&#123; background: red; margin:auto; &#125; &lt;/style&gt; &lt;div class=\"one\"&gt; &lt;div class=\"two\"&gt;111111111111&lt;/div&gt; &lt;/div&gt;","raw":null,"content":null,"categories":[{"name":"web开发","slug":"web开发","permalink":"http://www.qiakr.com/categories/web开发/"}],"tags":[]},{"title":"CSS工具类使用说明","slug":"tool-css","date":"2016-07-21T12:09:58.000Z","updated":"2016-07-21T12:11:34.000Z","comments":true,"path":"2016/07/21/tool-css/","link":"","permalink":"http://www.qiakr.com/qkfe/2016/07/21/tool-css/","excerpt":"旨在现在的CSS框架下去快速修正个别样式，减少添加CSS的工作量，但不可滥用工具类，如列表项的样式较多里，并不实用，常用于容器类型的标签，建议样式在三个左右时，使用工具类组合，四个以上时，添加独立的class","keywords":null,"text":"旨在现在的CSS框架下去快速修正个别样式，减少添加CSS的工作量，但不可滥用工具类，如列表项的样式较多里，并不实用，常用于容器类型的标签，建议样式在三个左右时，使用工具类组合，四个以上时，添加独立的class 内容百分比、字体大小、行高、字体风格、字体类型、外边距、内边距、块级显示、边框、颜色、背景颜色、浮动、定位、overflow、对齐、可见性、分隔线、文本溢出、动画 百分比定义了常用的百分比 10 - 100，步进值10，加两个特殊百分比 25%、33.3%，分别对应四等分与三等分 字体大小定义了大小为0、10、12、13、14、16、18几种常用字体大小 字体大小设置为0，通常可以用于去掉inline-block后产生的间隔，或可以用于隐藏文字、去掉img元素在容器中的间隔 行高定义了24、28、30常用行高 字体风格定义了 普通、加粗、斜体、中划线 常用样式 字体类型定义了 Arial 字体，用于数字 外边距定义了 0-30 的 margin，5-30的 margin-top/margin-right/margin-bottom, 步进值为5 内边距定义了 0-30 的 padding，5-30的 padding-top/padding-right/padding-bottom, 步进值为5 块级显示定义了几个显示方式 隐藏、行内、块级、行内块级 边框定义了1px的全边框，上、下、左、右边框的样式 颜色定义了常用安全色#333、#999、#666、#888、常用颜色红、蓝、绿、橙、白的样式 背景颜色定义了两中背景色 白色 与 灰色 浮动定位定义了 左浮动 l, 右浮动 r overflow定义的 overflow 的 hidden/auto 两种的样式 对齐定义了6中文本对齐方式，水平左中右，垂直上中下几中对齐 可见性定义了 visibility 的 hidden/visible 两种样式 分隔线定义了水平和垂直分隔线，便需要配合margin和背景颜色来使用 文本溢出定义了文本超出以...显示的工具类，需要配合max-width来使用 动画定义了常用动画过渡处理的样式 用法示例 See the Pen Tool.css by LT (@togglelt) on CodePen. 源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/*!* author: LT* version: v0.0.1* github: https://github.com/git-lt/Tool.css/blob/master/Tool.css*//* percent width value */ .pct10&#123;width:10%;&#125; .pct20&#123;width:20%;&#125; .pct25&#123;width:25%;&#125; .pct30&#123;width:30%;&#125; .pct33&#123;width:33.3%;&#125; .pct40&#123;width:40%;&#125; .pct50&#123;width:50%;&#125; .pct60&#123;width:60%;&#125; .pct70&#123;width:70%;&#125; .pct80&#123;width:80%;&#125; .pct90&#123;width:90%;&#125; .pct100&#123;width:100%;&#125;/* font-size */ .f0&#123;font-size:0;&#125; .f10&#123;font-size:10px;&#125; .f12&#123;font-size:12px;&#125; .f13&#123;font-size:13px;&#125; .f14&#123;font-size:14px;&#125; .f16&#123;font-size:16px;&#125; .f18&#123;font-size:18px;&#125; /*line-height*/ .lh24 &#123; line-height: 24px;&#125; .lh28 &#123; line-height: 28px;&#125; .lh30 &#123; line-height: 30px;&#125;/* font-style */ .n&#123;font-weight:400; font-style:normal; white-space: normal;&#125; .b&#123;font-weight:bold;&#125;.i&#123;font-style:italic;&#125;.del &#123;text-decoration: line-through;&#125;/* font-family */ .fa&#123;font-family:Arial;&#125;/* margin */ .m0 &#123;margin:0px;&#125; .m5 &#123;margin:5px;&#125; .m10 &#123;margin:10px;&#125; .m15 &#123;margin:15px;&#125; .m20 &#123;margin:20px;&#125; .m25 &#123;margin:25px;&#125; .m30 &#123;margin:30px;&#125; .mt5 &#123;margin-top:5px;&#125; .mt10 &#123;margin-top: 10px;&#125; .mt15 &#123;margin-top: 10px;&#125; .mt20 &#123;margin-top: 20px;&#125; .mt25 &#123;margin-top: 20px;&#125; .mt30 &#123;margin-top: 30px;&#125; .ml5 &#123;margin-left:5px;&#125; .ml10 &#123;margin-left:10px;&#125; .ml15 &#123;margin-left:15px;&#125; .ml20 &#123;margin-left:20px;&#125; .ml25 &#123;margin-left:20px;&#125; .ml30 &#123;margin-left:30px;&#125; .mb5 &#123;margin-bottom:5px;&#125; .mb10 &#123;margin-bottom:10px;&#125; .mb15 &#123;margin-bottom:10px;&#125; .mb20 &#123;margin-bottom:20px;&#125; .mb25 &#123;margin-bottom:20px;&#125; .mb30 &#123;margin-bottom:30px;&#125; .mr5 &#123;margin-right:5px;&#125; .mr10 &#123;margin-right:10px;&#125; .mr15 &#123;margin-right:15px;&#125; .mr20 &#123;margin-right:20px;&#125; .mr25 &#123;margin-right:25px;&#125; .mr30 &#123;margin-right:30px;&#125;/* padding */ .p0 &#123;padding:0px;&#125; .p5 &#123;padding:5px;&#125; .p10 &#123;padding:10px;&#125; .p15 &#123;padding:15px;&#125; .p20 &#123;padding:20px;&#125; .p25 &#123;padding:25px;&#125; .p30 &#123;padding:30px;&#125; .pt5 &#123;padding-top: 5px;&#125; .pt10 &#123;padding-top: 10px;&#125; .pt15 &#123;padding-top: 15px;&#125; .pt20 &#123;padding-top: 20px;&#125; .pt25 &#123;padding-top: 25px;&#125; .pt30 &#123;padding-top: 30px;&#125; .pl5 &#123;padding-left: 5px;&#125; .pl10 &#123;padding-left: 10px;&#125; .pl15 &#123;padding-left: 15px;&#125; .pl20 &#123;padding-left: 20px;&#125;.pl25 &#123;padding-left: 25px;&#125; .pl30 &#123;padding-left: 30px;&#125; .pb5 &#123;padding-bottom: 5px;&#125; .pb10 &#123;padding-bottom: 10px;&#125; .pb15 &#123;padding-bottom: 15px;&#125; .pb20 &#123;padding-bottom: 20px;&#125; .pb25 &#123;padding-bottom: 25px;&#125; .pb30 &#123;padding-bottom: 30px;&#125; .pr5 &#123;padding-right: 5px;&#125; .pr10 &#123;padding-right: 10px;&#125; .pr15 &#123;padding-right: 15px;&#125; .pr20 &#123;padding-right: 20px;&#125; .pr25 &#123;padding-right: 25px;&#125; .pr30 &#123;padding-right: 30px;&#125;/*display*/ .dn&#123;display:none;&#125; .di&#123;display:inline;&#125; .db&#123;display:block;&#125; .dib&#123;display:inline-block;&#125;/*border*/ .bdr &#123;border:1px solid #f2f2f2;&#125; .bdr-l &#123;border-left:1px solid #f2f2f2;&#125; .bdr-r &#123;border-right:1px solid #f2f2f2;&#125; .bdr-t &#123;border-top:1px solid #f2f2f2;&#125; .bdr-b &#123;border-bottom:1px solid #f2f2f2;&#125; /*color*/ .c-3 &#123;color:#333;&#125; .c-6 &#123;color:#666;&#125; .c-8 &#123;color:#888;&#125; .c-9 &#123;color:#999;&#125; .c-rd &#123;color: #F44336;&#125; .c-bl &#123;color: #0894EC;&#125; .c-wt &#123;color: #FFFFFF;&#125; .c-gr &#123;color: #4CD964;&#125; .c-or &#123;color: #FF6600;&#125;/*backgroud-color*/ .bg-wt &#123; background-color: #fff; &#125;.bg-f5 &#123; background-color: #f5f5f5; &#125; /*float &amp; position*/ .l &#123;float: left;&#125;.r &#123;float: right;&#125; .clearfix:before,.clearfix:after &#123;display: table;content: \" \";&#125;.clearfix:after &#123;clear: both;&#125; .rel &#123;position: relative;&#125;.abs &#123;position: absolute;&#125;/* align */ .vt &#123;vertical-align: top;&#125;.vb &#123;vertical-align: bottom;&#125;.vm &#123;vertical-align: middle;&#125; .tc &#123;text-align: center;&#125; .tl &#123;text-align: left;&#125; .tr &#123;text-align: right;&#125;/* overflow */ .ovh&#123;overflow:hidden;&#125; .ova&#123;overflow:auto;&#125;/* visibility */ .vh&#123;visibility:hidden;&#125;.vv&#123;visibility:visible;&#125;/*hide scrollbar*/ .no-scroll &#123;overflow: hidden !important; height: 100% !important;&#125;.no-scroll body &#123;overflow: hidden; height: 100%;&#125;/*divider line*/ .dvd-x &#123;display: block;font-size: 0; height: 1px; clear: both;&#125; .dvd-y &#123;display:inline-block; font-size: 0; width: 1px;&#125;/* ellipsis */ .ell&#123;text-overflow:ellipsis; white-space:nowrap; overflow:hidden;&#125;/*transition*/ .trans&#123;-ms-transition:all 0.2s; -webkit-transition:all 0.2s; transition:all 0.2s;&#125;","raw":null,"content":null,"categories":[{"name":"web开发","slug":"web开发","permalink":"http://www.qiakr.com/categories/web开发/"}],"tags":[]},{"title":"组件编写规范","slug":"Component-define-guide","date":"2016-07-17T08:03:53.000Z","updated":"2016-07-17T08:30:18.000Z","comments":true,"path":"2016/07/17/Component-define-guide/","link":"","permalink":"http://www.qiakr.com/qkfe/2016/07/17/Component-define-guide/","excerpt":"组件的封装有利用于代码的复用，封装统一的数据处理逻辑，对外提供接口，灵活配置与扩展，调用方便，利于维护。","keywords":null,"text":"组件的封装有利用于代码的复用，封装统一的数据处理逻辑，对外提供接口，灵活配置与扩展，调用方便，利于维护。 原则 开闭原则：对内修改关闭，对外扩展开放 单例模式：同一个组件，在多次调用时，只使用一个单例 闭包使用闭包：减少全局变量的污染，避免与其它插件冲突 严格模式 (strict mode)使用严格模式：添加 use strict 标识 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的Javascript做好铺垫。 组件说明组件应添加组件说明，包含：组件名称、作者、版本、依赖项、使用方式、源码地址 12345678/*** module: Button* author: XXX* version: v0.0.1* use age: ....* deps: [...]* github: ...**/ 构造函数组件的状态和属性都应该在构造函数中进行初始化 插件定义通用插件定义 在内部返回每一个jQuery对象，插件的实例缓存到jQ对象的data中 要的参数的类型调用组件不同的方法 123456789function Plugin(option) &#123; return this.each(function () &#123; var $this = $(this) var data = $this.data('qk.button') if (!data) $this.data('qk.button', (data = new Button(this))) if (typeof option == 'string') data[option].call($this) &#125;) &#125; 事件的命名空间在开发较复杂的组件时，应添加事件命名空间，方便事件的管理，参见bootstrap modal组件 对外开放配置组件通常有很多的配置，将配置接口对外开放，可方便用户对组件进行详情的配置与自定义 1$.bn.button.defaults=&#123; ... &#125; 注意： 组件内部使用到的模板、class、id等都应该放到配置中，以便使用者自定义 对外开放构造器将构造器对外开放，可方便外部对插件进行扩展升级 1$.fn.button.Constructor = Button; 解决与其它重名插件的冲突为防止组件名称与其它组件重名，应对外提供onConflict接口进行重命名。 12var old = $.fn.button;$.fn.button.noConflict = function () &#123;$.fn.button = old;return this;&#125; 生命周期组件的生命周期包含：组件状态初始化、数据初始化、事件绑定、更新、销毁 结构 PUBLIC CLASS DEFINITION：类定义，定义了插件构造方法类及方法。 PLUGIN DEFINITION：插件定义，上面只是定义了插件的类，这里才是实现插件的地方。 PLUGIN NOCONFLICT:插件命名冲突解决 DATA-API：DATA-属性接口 模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/*** module: Button* author: XXX* version: v0.0.1* use age: ....* deps: [...]* github: ...**/!function ($) &#123; \"use strict\"; // CLASS DEFINITION // ================ var Button = function (element, options) &#123;/*some code*&#125; Button.VERSION='v1.0.1'; Button.prototype.setState = function (state) &#123;/*some code*/&#125; Button.prototype.toggle = function () &#123;/*some code*/&#125; // PLUGIN DEFINITION // ================= function Plugin(option) &#123; return this.each(function () &#123; var $this = $(this) var data = $this.data('qk.button') if (!data) $this.data('qk.button', (data = new Button(this))) if (typeof option == 'string') data[option].call($this) &#125;) &#125; var old = $.fn.button; $.fn.button = Plugin; $.fn.button.Constructor = Button; $.fn.button.defaults = &#123;loadingText: 'loading...'&#125; // NO CONFLICT // =========== $.fn.button.noConflict = function () &#123; $.fn.button = old; return this; &#125; // DATA-API // ======== $(document).on('click.button.data-api', '[data-toggle^=button]', function (e) &#123;/*some code*/&#125;)&#125;(jQuery, window, undefined);","raw":null,"content":null,"categories":[{"name":"web开发","slug":"web开发","permalink":"http://www.qiakr.com/categories/web开发/"}],"tags":[]},{"title":"模块编写规范","slug":"AMD-Module-guide","date":"2016-07-17T08:03:53.000Z","updated":"2016-09-01T03:26:57.000Z","comments":true,"path":"2016/07/17/AMD-Module-guide/","link":"","permalink":"http://www.qiakr.com/qkfe/2016/07/17/AMD-Module-guide/","excerpt":"React或Vue给我来带来的不是仅仅是View层的改变和便捷的组件化开发，更多的是围绕这套开发体系，整个技术栈的应用和实践。但很多管理系统还是基于传统的AMD或CMD开发，配合Jquery插件使用，所以日常的组件和模块编写应该有一定的规范，以减少多人配合开发的沟通成本，统一编码风格，便于维护管理，也便于后期重构切换到新的技术栈。","keywords":null,"text":"React或Vue给我来带来的不是仅仅是View层的改变和便捷的组件化开发，更多的是围绕这套开发体系，整个技术栈的应用和实践。但很多管理系统还是基于传统的AMD或CMD开发，配合Jquery插件使用，所以日常的组件和模块编写应该有一定的规范，以减少多人配合开发的沟通成本，统一编码风格，便于维护管理，也便于后期重构切换到新的技术栈。 是编写模块还是编写组件？模块与组件的区别 组件：可重用，对独立功能生命周期的封装。对外提供统一的配置和调用接口。遵循开闭原则：对外扩展开放，对内修改关闭。 模块：不可重用，对一个业务处理的封装，有独有的业务处理代码，可调用各种组件。 依赖jQuery的组件挂载为jQuery的静态方法 还是 挂载到jQuery的实例上？ 挂载到jQuery的实例上: 页面上需要实例化多个功能一样的组件时，依赖页面上的DOM结构，依赖父容器初始化 挂载为jQuery的静态方法: 不依赖页面上的DOM，以处理数据为主 独立的组件对纯数据层面的处理，比如常用的Utils模块、数据验证、xss模块、加密解密、cookie操作、特性检测等 设计思想由前往后 从前往后推，先构建使用方式和场景 首先应该想到的是组件或模块的使用方法，它有那些方法和属性，应该怎样初始化 需要预留怎么样的配置或接口去做模块的扩展 需要依赖的资源 结构和接口设计模块全局变量 CONF 模块配置: api地址，公用的配置和常量 pageVM 模块数据模型: 如果页面有大量表单元素，使用avalon的VM模型做数据的双向绑定，如果没有，则不需要此变量 pageView 模块业务逻辑: 页面主逻辑对象，包含：init/bindEvents/getData/initComponents等方法，init中只对业务做初始化操作 init 对外接口: 提供对外统一调用初始化方法 模块模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950define(['moment'],function(moment)&#123; var pageVM, CONF, pageView; // [ TODO: 模块配置 ] CONF=&#123; apiGetList:'getOrderList.json', &#125;; // [ TODO: 模块主逻辑处理 ] pageView = &#123; init: function()&#123; // [ TODO: 模块数据模型初始化 ] (建议有表单时使用) !pageVM &amp;&amp; this.initVM(); //初始化ViewModel this.initComponents(); // 初始化组件：select2、tolltip、uploader this.getListData(); //加载列表数据 this.selectChangeEv(); //注册下拉框变化事件 &#125;, initVM: function()&#123; pageVM = avalon.define(&#123; $id:'recordsCtr', searching:false, searchPms:&#123; status:'0', startTime:'', endTime:'', index:0, length:10, &#125; searchEv:function(e)&#123; e.preventDefault(); pageVM.searching=true; pageVM.searchPms.index=0; page.getListData(); &#125; &#125;); &#125;, selectChangeEv: function()&#123; ... &#125;, initComponents: function()&#123; ... &#125;, getListData: function()&#123; ... &#125; &#125; // [ TODO: 对外提供统一的调用接口 ] return &#123; init:function()&#123; pageView.init(); avalon.scan(); &#125; &#125;&#125;) 命名规则 接口名称： 以 api 开头 + 接口名 {apiGetSalesList:&#39;getSalesList&#39;} 事件名称： 事件名称 + 以 Ev 结尾 changeColorEv this指向修正：统一以 _this 命名 jQuery变量以$符号开头 $btnSearch=$(&#39;#btnSearch&#39;) 注意点 每个模块 init 是入口函数，也就是第一次加载时，整个模块代码顺序执行，以后的每次页面初始化，都只会执行init中的代码 每个模块 VM 中 $id 不允许重名 每个页面的artTemplate 模板id 不允许重名，因为模板有缓存，id相同会覆盖已有的模板 每个页面的DOM上的 id 尽量不要相同 数据加载处理要考虑的问题：数据列表加载的重用性、Loading触发的时机、何时需要分页、点击分页的处理、搜索处理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768getListData:function()&#123; // 构建查询参数 var pms = $.extend(&#123;&#125;,pageVM.$model.searchPms), url = CONF.apiGetList, //数据加载接口 $tbl = $('#listTbl'), //列表所在的容器 $tbdBox = $('#listTbd'), //列表项所在的tbody $total = $('#listTotal'), //数据总条数 $pageBox = $('#pageNumBox'); //分页容器 pms.startTime = Utils.getUnixTime(pms.startTime); pms.endTime = Utils.getUnixTime(pms.endTime); // 数据加载前显示Loading状态 $tbl.uiLoading('lg'); // 异步加载数据，并返回 deffered 对象 return $.post(url, pms) .done(function(data)&#123; if(data.status==='0')&#123; var listData = data.result.orderList, count = data.result.count; // 显示总数据条数 $total.text(count); //如果有数据 if(count&gt;0)&#123; // 渲染数据 $tbdBox.html(template('list_record_tpl', &#123;data: listData, url:CONF.orderUrl&#125;)); // 如果总数据条数大于请求的数据条数，就显示分页 if(count &gt; pms.length)&#123; $pageBox.pagination(&#123; totalData:count, coping:true, showData:pms.length, callback:function(i)&#123; // 计算起始索引 pms.index = (i-1)*pms.length; //显示Loading $tbl.uiLoading('lg'); //加载数据 $.post(url,pms) .done(function(data)&#123; // 渲染数据 $tbdBox.html(template('list_record_tpl', &#123;data: data.result.orderList, url:CONF.orderUrl&#125;)); // 隐藏Loading $tbl.uiLoading('lg'); &#125;); &#125; &#125;); &#125; &#125;else&#123; // 清空分页和列表数据，并添加为空说明 $tbdBox.html('&lt;tr&gt;&lt;td colspan=\"7\"&gt;&lt;p class=\"p20 c-8 text-center\"&gt; 未查询到相关数据 &lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;'); $pageBox.html(''); &#125; &#125;else&#123; // 提示加载失败信息 toastr.error(data.errmsg || '服务器繁忙！'); &#125; &#125;) .always(function()&#123; //加载失败时，隐藏loading状态 $tbl.uiLoading('lg'); pageVM.searching = false; &#125;);&#125;","raw":null,"content":null,"categories":[{"name":"web开发","slug":"web开发","permalink":"http://www.qiakr.com/categories/web开发/"}],"tags":[]},{"title":"HTML标签之Table","slug":"html-table","date":"2016-07-17T04:00:27.000Z","updated":"2016-07-20T04:34:11.000Z","comments":true,"path":"2016/07/17/html-table/","link":"","permalink":"http://www.qiakr.com/qkfe/2016/07/17/html-table/","excerpt":"Table标签使用","keywords":null,"text":"Table标签使用 1、&lt;thead&gt;整个第一行的部分没有包含数据，它只是每个列的标题。因此，我们可以&lt;thead&gt;元素来完成这件事情，它会包裹第一个&lt;tr&gt;元素(它会包裹所有的行所需要的头部信息)；当你使用了&lt;thead&gt;元素后，&lt;table&gt;元素中不能有直接的&lt;tr&gt;子元素，所有的行必须存在于&lt;thead&gt;，&lt;tbody&gt;和&lt;tfoot&gt;里面。要注意的是我们会把所有的数据行包含在&lt;tbody&gt;里面。 2、&lt;tfoot&gt;&lt;tfoot&gt;独一无二的一点是它在HTML中的位置，它紧跟着&lt;thead&gt;并位于&lt;tbody&gt;的前面！你可能会认为它是table标签结束前的最后一个元素，但情况并不是这样。因为页脚可能包含了用于理解表格的必要信息，因为在资源序列中它应当排在在数据的前面。 在一些元素位置根据需要从上至下跳动的布局中，&lt;tfoot&gt;是个不错的技巧。举个例子，虽然一个导航在屏幕的底部，但在HTML源码中导航应该在顶部。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;Favorite Color&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;th&gt;tfoot&lt;/th&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;Favorite Color&lt;/th&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Jim&lt;/td&gt; &lt;td&gt;00001&lt;/td&gt; &lt;td&gt;Blue&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;Favorite Color&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;th&gt;tfoot&lt;/th&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;Favorite Color&lt;/th&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Jim&lt;/td&gt; &lt;td&gt;00001&lt;/td&gt; &lt;td&gt;Blue&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 3、单元格：td和th在表格中一个独立的单元格总是&lt;td&gt;或&lt;th&gt;两者之一，只要你愿意，你可以把任何东西放进表格的单元格中，但要使这些元素成为表格中的单元格元素。&lt;th&gt;是“表格的标题”一般用在一列的第一格,里面的内容会自动加粗加黑他们，&lt;td&gt;是“表格的数据”。 4、基本样式你看到的大多数表格都用颜色和线条来区别表格的不同部分。边框是非常常见的。默认的，所有的单元格相互之间都有2px的空隙bordercolor =”边框颜色”cellspacing =”单元格之间的距离，外边距”cellpadding =”单元格与内容之间的距离，内边距”bgcolor =”背景颜色”align =”水平对齐方式”valign =”垂直对齐方式” border-collapse 用于表格属性, 表示表格的两边框合并为一条。 默认值：separate边框会被分开。不会忽略border-spacing 和 empty-cells 属性。 collapse：如果可能，边框会合并为一个单一的边框。会忽略border-spacing 和 empty-cells 属性。 inherit：规定应该从父元素继承border-collapse属性的值。 border-spacing 属性设置相邻单元格的边框间的距离（仅用于“边框分离”模式）。 length length: 规定相邻单元的边框之间的距离。使用 px、cm 等单位。不允许使用负值。 如果定义一个 length 参数，那么定义的是水平和垂直间距。 如果定义两个 length参数，那么第一个设置水平间距，而第二个设置垂直间距。 inherit:规定应该从父元素继承 border-spacing 属性的值。 table表格td设置宽度后文字太多导致自动换行：1.设置表格table的样式为：style=”table-layout:fixed;”2.然后设置td的样式为：style=”word-wrap:break-word;” 5、合并单元格有两个能应用在任何单元格中的重要的属性（&lt;td&gt;或&lt;th&gt;）：colspan 和 rowspan 。他们接受任何大于等于2的正整数。如果一个 td 元素的 colspan 值为2（&lt;td colspan=&quot;2&quot;&gt;），它将仍然是单独的单元格，但它会在一行中水平的占据两个单元格的空间。rowspan也一样，但它作用于垂直方向。 6、使语义元素表现地像一个表格display: table / &lt;table&gt; /display: table-cell / &lt;td&gt; /display: table-row / &lt;tr&gt; /display: table-column / &lt;col&gt; /display: table-column-group / &lt;colgroup&gt; /display: table-footer-group / &lt;tfoot&gt; /display: table-header-group / &lt;thead&gt; / 注意这里没有的值，这是因为语义的关系，和的表现实际上是相同的，所以没必要多增加这样一个值。 display: inline-table表格是自适应宽度的。它就像 inline-block 元素一样。顾名思义，这个值使得它们成为一个 inline-block 元素而不会产生换行。 7、colgroup与colcolgroup、col 标签用来定义表格列的分组。通过使用 &lt;colgroup&gt;标签，可以向整个列应用样式，而不需要重复为每个单元格或每一行设置样式。如果想对 &lt;colgroup&gt; 中的某列定义不同的属性，请在 &lt;colgroup&gt; 标签内使用 &lt;col&gt; 标签。col标签为表格中一个或多个列定义属性值。colgroup标签用于对表格中的列进行组合，以便对其进行格式化。 8、“隐含”元素和未关闭的标签 &lt;col&gt;标签是属于那种无内容的不需要闭合的标签，类似&lt;br&gt;/&lt;br /&gt;； &lt;td&gt;元素在这些情况中是无需闭合的：“如果元素后面没有更多的&lt;td&gt;或&lt;th&gt;元素或者在它父元素中没有更多的内容，闭合标签是可以省略的。”； 缺少的&lt;/tr&gt;标签的原理也是相同的：“如果元素后面没有紧跟着一个元素或者如果它父元素组(,或者 )没有更多的内容，结束标签是可以省略的。”； 9、高亮鼠标所在的行/列/单元格1234567891011121314151617181920td:hover &#123; background: yellow;&#125;tr:hover &#123; background: yellow;&#125;鼠标移动动一个单元格的时候他所在的列与行全部选中var allCells = $(\"td, th\");allCells.on(\"mouseover\", function() &#123; var el = $(this), pos = el.index(); el.parent().find(\"th, td\").addClass(\"hover\"); allCells.filter(\":nth-child(\" + (pos+1) + \")\").addClass(\"hover\"); &#125;) .on(\"mouseout\", function() &#123; allCells.removeClass(\"hover\"); &#125;); 表格自身设置圆角时需要设置border-collapse: separate;","raw":null,"content":null,"categories":[{"name":"web开发","slug":"web开发","permalink":"http://www.qiakr.com/categories/web开发/"}],"tags":[]},{"title":"数组方法介绍","slug":"array-methods","date":"2016-07-17T04:00:27.000Z","updated":"2016-07-20T04:30:55.000Z","comments":true,"path":"2016/07/17/array-methods/","link":"","permalink":"http://www.qiakr.com/qkfe/2016/07/17/array-methods/","excerpt":"介绍数组方法的基本用法","keywords":null,"text":"介绍数组方法的基本用法 1. 数组的创建12345var array= new Array();var arra=[];var array=[size];var array=[ele,ele,ele,...]var a=1; var array=[a,a+1]; 2. 数组操作2.1 array.push(ele，ele，..)和array.pop() 后进和后出123456push将参数添加到原数组末尾，并返回数组的长度 var a = [1,2,3,4,5];var b = a.push(6,7); //a:[1,2,3,4,5,6,7] b:7pop删除原数组最后一项，并返回删除元素的值；如果数组为空则返回undefinedvar a = [1,2,3,4,5];var b = a.pop(); //a:[1,2,3,4] b:5 2.2 array.unshift(ele,ele,..)和array.shift() 先进和先出123456将参数添加到原数组开头，并返回数组的长度 var a = [1,2,3,4,5];var b = a.unshift(6,7); //a:[6,7,1,2,3,4,5] b:7删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined var a = [1,2,3,4,5]; var b = a.shift(); //a:[2,3,4,5] b:1 2.3 arrary.splice(index,many,ele,ele..)1234index:插入或删除的起始位置 many:进行操作的长度 ele:要插入的值(可选)数组中插入或者删除元素,改变原始数组，返回被删除的项目var a = [1,2,3,4,5]; var b = a.splice(2,2,7,8,9); //a:[1,2,7,8,9,5] b:[3,4] 2.4 arrary.concat()123返回一个新数组，是将参数添加到原数组中构成的 var a = [1,2,3,4,5]; var b = a.concat(6,7); //a:[1,2,3,4,5] b:[1,2,3,4,5,6,7] 2.5 array.slice(0) array.concat()12345678拷贝数组var array1 = new Array(\"1\",\"2\",\"3\"); var array2; array2 = array1.slice(0)var array1 = new Array(\"1\",\"2\",\"3\"); var array2; array2 = array1.concat(); 2.6 array.reverse()123将数组反序 var a = [1,2,3,4,5]; var b = a.reverse(); //a:[5,4,3,2,1] b:[5,4,3,2,1] 2.7 array.sort(sortby)12345sortby:可选。规定排序顺序。必须是函数数组排序var a = [1,3,\"a\",2,5]; var b = a.sort();console.log(a,b) [1, 2, 3, 5, \"a\"] [1, 2, 3, 5, \"a\"] 2.8 array.join(separator)123将数组的元素组起一个字符串，以separator为分隔符，省略的话则用默认用逗号为分隔符.var a = [1,2,3,4,5]; var b = a.join(\"|\"); //a:[1,2,3,4,5] b:\"1|2|3|4|5\" ES5后新加入内容 2.8 array.forEach(function(v,i,a))1234v:数值 i:索引 a:数组本身数组元素，索引，数组本身,无提前终止break,可使用try，catch语句终止.var a = [1,2,3,4,5]; a.forEach(function(v,i,a)&#123;a[i]=v+1;&#125;) [2,3,4,5,6] 2.9 array.map()123每个元素传给指定的函数，返回一个数组，类似forEach但返回新数组var a = [1,2,3]; b=a.map(function(x)&#123;return x*x;&#125;) [1,4,9] 2.10 array.filter()12345每个元素传给指定的函数，返回一个调用数组的子集var a = [1,2,3]; b=a.filter(function(x)&#123;return x&gt;1;&#125;)console.log(a,b)[1, 2, 3] [2, 3] 2.11 array.every() array.some()1234每个元素传给指定的函数，返回true or falsse var a = [1,2,3]; a.every(function(x)&#123;return x&gt;1;&#125;) false 所有a.sone(function(x)&#123;return x&gt;1;&#125;) true 存在 2.12 array.reduce() array.reduceRight()123456每个元素传给指定的函数，进行组合，传回单个值var a = [1,2,3]; b=a.reduce(function(x,y)&#123;return x+y;&#125;,0) 求和console.log(b)2个参数 1个位所执行的函数 2位初始值(可选)reduceRight() 从右到左执行 2.13 array.indexOf() array.lastIndexOf()12345整个数组中搜寻给定的值,有返回其位置,无返回-1，lastIndexOf从右开始搜寻var a = [1,2,3]; a.indexOf(1) 0a.indexOf(6) -1a.lastIndexOf(1) 2","raw":null,"content":null,"categories":[{"name":"web开发","slug":"web开发","permalink":"http://www.qiakr.com/categories/web开发/"}],"tags":[]},{"title":"ES5特性介绍","slug":"ES5-new-features","date":"2016-06-29T07:50:10.000Z","updated":"2016-06-29T08:09:17.000Z","comments":true,"path":"2016/06/29/ES5-new-features/","link":"","permalink":"http://www.qiakr.com/qkfe/2016/06/29/ES5-new-features/","excerpt":"2011年6月，ECMAscript 5.1版发布，并且成为ISO国际标准，简称ES5。","keywords":null,"text":"2011年6月，ECMAscript 5.1版发布，并且成为ISO国际标准，简称ES5。 浏览器支持IE9+ , Android Browser 4.3+, Safari5.1+, Chrome22+, FireFox20+, Opera12.1+ 严格模式在函数内顶部或模块顶部添加: &quot;use strict&quot;; 以开启对该作用域的语法检查。 在严格模式下有以下限制： 未声明的变量赋值抛出一个ReferenceError, 而不是创建一个全局变量。 var定义只能在函数级，if、for、while、switch等不能有var定义 一个对象字面量中不能声明两个名称相同的属性。一个函数也不能有名称相同的形式参数。 arguments 不能使用arguments、eval、let、const作为标识符(变量名方法名等) 不能修改作为函数内部对象的arguments，因此形式参数和arguments之间不再有同步变化 不能访问arguments.callee ES5中定义了arguments.caller属性，它的值始终是undefined，主要用于区分arguments.caller和函数的caller，但是不能在严格模式下访问 普通的函数调用中this是null 试图改变只读属性将会抛出异常 delete失败会抛出异常 eval中不再能声明变量，声明的函数将会变成全局的 12345678910function f1 (c1, c2)&#123; &apos;use strict&apos;; var arguments=9; // Unexpected eval or arguments in strict mode console.log(arguments); //[2, 3] console.log(arguments[0]); //2 arguments[0]=12; console.log(arguments[0]); //12 console.log(c1); //2 console.log(arguments.callee);//Uncaught TypeError: &apos;caller&apos;, &apos;callee&apos;, and &apos;arguments&apos; properties may not be accessed&#125; JSON对象ES5提供一个全局的JSON对象 JSON.stringify(obj, fn/arr, number) 序列化 第一个参数是待转换的 ECMAScript 对象， 第二个参数可以是一个函数或是数组。如果是函数，则转换的结果由该函数来确定；如果是数组，则只有出现在数组中的属性名称，才会出现在转换之后的结果中。 第三个参数是用来控制转换结果中文本的缩进，以更好的进行显示。 JSON.parse(str, fn) 反序列化 第一个参数是 JSON 文本，需要符合 JSON 格式的要求。 第二个参数是一个函数，可以用来对解析过程中得到的属性名值对进行过滤和转换。 1234567891011121314151617181920212223242526272829303132333435var jsonStr = &apos;&#123;&quot;a&quot;:1, &quot;b&quot;:2, &quot;c&quot;:3&#125;&apos;; JSON.parse(jsonStr); JSON.parse(jsonStr, function(key, value) &#123; return typeof value === &apos;number&apos; ? value * 2 : value; &#125;); // 结果为 &#123;a:2, b:4, c:6&#125; JSON.parse(jsonStr, function(key, value) &#123; return typeof value === &apos;number&apos; &amp;&amp; value % 2 === 0 ? undefined : value; &#125;); // 结果为 &#123;a:1, b:3&#125;var user = &#123; name : &apos;Alex&apos;, password : &apos;password&apos;, email : &apos;alex@example.org&apos; &#125;; JSON.stringify(user); JSON.stringify(user, [&apos;name&apos;]); // 输出结果为“&#123;&quot;name&quot;:&quot;Alex&quot;&#125;” JSON.stringify(user, function(key, value) &#123; if (key === &apos;email&apos;) &#123; return &apos;******&apos;; &#125; if (key === &apos;password&apos;) &#123; return undefined; &#125; return value; &#125;); // 输出结果为“&#123;&quot;name&quot;:&quot;Alex&quot;,&quot;email&quot;:&quot;******&quot;&#125;” JSON.stringify(user, null, 4);=&gt;&#123; &quot;name&quot;: &quot;Alex&quot;, &quot;password&quot;: &quot;password&quot;, &quot;email&quot;: &quot;alex@example.org&quot;&#125; 注意：JSON.parse()必须接收严格的JSON格式，否则报错，比如键名必须使用双引号括起来 Object的扩展对象的属性有了更多的控制 继承相关方法：create()、getPrototypeOf() 属性相关方法：defineProperty()、defineProperties()、getOwnPropertyDescriptor()、getOwnPropertyNames()、keys() 防篡改方法：preventExtensions()、isExtensible()、seal()、isSealed()、freeze()、isFrozen() Object.preventExtensions、Object.seal 和 Object.freeze 函数可以用来保护对象，防止被第三方有意或无意的修改。 123456789101112131415161718192021222324252627282930313233343536373839404142434445var cat = &#123;&#125;;Object.defineProperty(cat, &quot;name&quot;, &#123; value: &quot;Maru&quot;, writable: false, enumerable: true, configurable: false&#125;);Object.defineProperty(cat, &quot;skill&quot;, &#123; value: &quot;exploring boxes&quot;, writable: true, enumerable: true, configurable: true&#125;);var obj = &#123;&#125;; Object.defineProperty(obj, &apos;val&apos;, &#123;&#125;); // 创建一个新属性，特性为默认值obj.val = 1; Object.defineProperty(obj, &apos;CONSTANT&apos;, &#123;value : 32, writable : false&#125;); // 创建一个只读属性obj.CONSTANT = 16; // 对属性的修改是无效的，但是不会抛出错误Object.defineProperty(obj, &quot;newVal&quot;, &#123;enumerable: true&#125;); for (var key in obj) &#123; console.log(key); // 可以枚举出 newVal &#125;var initValue = 0; Object.defineProperty(obj, &quot;initValue&quot;, &#123; get : function() &#123; return initValue; &#125;, set : function(val) &#123; if (val &gt; 0) &#123; initValue = val; &#125; &#125; &#125;);var obj = &#123;val : 1&#125;; obj.newVal = &quot;Hello&quot;; Object.seal(obj); Object.defineProperty(obj, &apos;anotherVal&apos;, &#123;&#125;); // 抛出 TypeError 错误 Array的扩展扩展的迭代或缩小方法都不会改变原有的数组，只会返回处理后的新数组。 判断方法：添加了静态方法Array.isArray(obj)用于判断obj是否为一个Array对象的实例。 索引方法：添加了两个用于查找指定项索引的方法indexOf()和lastIndexOf()。查找时使用全等（===）进行匹配。 迭代方法：添加了every()、some()、forEach()、map()、filter()方法。 缩小方法：添加了reduce()和reduceRight()方法。 12345678910var arr = [2,9,4,5,3,7,2];console.log(Array.isArray(arr)); //trueconsole.log(arr.indexOf(2)); //0console.log(arr.lastIndexOf(2)); //6console.log(arr.every(function(v,i)&#123; return v &gt; 1 &#125;)); //trueconsole.log(arr.some(function(v,i)&#123; return v&gt;6 &#125;)); //trueconsole.log(arr.map(function(v,i)&#123; return v&gt;5 &#125;)); //[false, true, false, false, false, true, false]console.log(arr.filter(function(v,i)&#123; return v&gt;6 &#125;)); //[9, 7]console.log(arr.reduce(function(pre, v, i)&#123; return res+v &#125;)); //32console.log(arr.reduceRight(function(pre, v, i)&#123; return res*v &#125;)); //15120 Function的扩展 函数中不能出现两个同名的形式参数 不能给函数的caller属性赋值 未指定环境对象而调用函数，this值不会指向window，而是undefined 添加了bind()方法。 规范化了一个函数对象的属性caller，用于指向调用当前函数的函数的引用。 prototype是不可枚举的 Function.prototype.bind 用于改变函数在执行时的this指向 1234567var obj = &#123; name : &quot;alex&quot; &#125;; function func() &#123; console.log(this.name); &#125; var func1 = func.bind(obj)(); // alex String的扩展添加了trim()方法 String.prototype.trim Date的扩展添加了Date.now()、Date.prototype.toJSON()等方法。 123Date.now() 等价于 new Date().getTime()new Date().toJSON(); //&quot;2016-06-29T01:53:15.560Z&quot; RegExp对象在ES3中，使用正则表达式字面量时共享一个RegExp实例，而在ES5中，每次使用正则表达式字面量时都要创建新的RegExp实例，就像使用RegExp构造函数一样。 1/cat/g 等价于 new RegExp(&quot;cat&quot;, &quot;g&quot;); 相关阅读：深入探讨 ECMAScript 规范第五版","raw":null,"content":null,"categories":[{"name":"web开发","slug":"web开发","permalink":"http://www.qiakr.com/categories/web开发/"}],"tags":[{"name":"js","slug":"js","permalink":"http://www.qiakr.com/tags/js/"}]},{"title":"CSS 编码指南","slug":"css-style-guide","date":"2016-05-07T08:03:53.000Z","updated":"2016-05-07T08:12:20.000Z","comments":true,"path":"2016/05/07/css-style-guide/","link":"","permalink":"http://www.qiakr.com/qkfe/2016/05/07/css-style-guide/","excerpt":"前言CSS 作为网页样式的描述语言，在前端开发中有着广泛的应用。本文档的目标是使 CSS 代码风格保持一致，容易被理解和被维护。 虽然本文档是针对 CSS 设计的，但是在使用各种 CSS 的预编译器(如 less、sass、stylus 等)时，适用的部分也应尽量遵循本文档的约定。","keywords":null,"text":"前言CSS 作为网页样式的描述语言，在前端开发中有着广泛的应用。本文档的目标是使 CSS 代码风格保持一致，容易被理解和被维护。 虽然本文档是针对 CSS 设计的，但是在使用各种 CSS 的预编译器(如 less、sass、stylus 等)时，适用的部分也应尽量遵循本文档的约定。 核心规范核心规范规定了洽客前端使用的css框架和基础类，主要包含两个css文件，weui.css 与 style.css。 基础类style.css = 重置类reset.css + 原子类base.css + 组件类component.css; 重置类 包含了对基本类型标签样式的重置 原子类 包含了常用的工具：图像大小，百分比，文本对齐，常用行高，常用字体大小，常用边距，学用字体颜色，边框等。 组件类 包含了图标字体iconfont，弹框，登录等 weui框架见 weui文档说明 页面引用，先引用 style.css 再引入 weui.css 兼容性要求 PC端兼容webkit内核浏览器即可 移动端兼容到Android4.4及以上，iOS7.0及以上版本。 图片使用 小图标：单色图标使用原则 css图标 &gt; iconfont &gt; gif &gt; png 图片使用：优先使用jpg，PS导出质量为高，压缩比率为75%左右。 基本规范 基本规范规定了代码的编写风格，推荐使用下面的规范，以便以团队成员的沟通协作。 代码风格文件 CSS 文件使用无 BOM 的 UTF-8 编码。 解释：win系统自带的记事本新建的txt文件都是带BOM的，带BOM的叫UTF-8+，不带BOM的为UTF-8，部分语言或工具对UTF-8+格式的文档不能正确解析。 缩进 属性展开写法下：以 2 个空格做为层级缩进 推荐采用折叠属性写法，将多个属性写在同一行，属性过多可多行书写 12345.ui-mask &#123; position: fixed; top: 0; right: 0; bottom: 0; left: 0; z-index: 1100; display: none; width: 100%; height: 100%; background-color: rgba(0,0,0,.6); opacity: 0; -webkit-transition: opacity .15s; transition: opacity .15s; &#125; 空格 选择器 与 { 之间必须包含空格。 属性名 与之后的 : 之间不允许包含空格， : 与 属性值 之间必须包含空格。 列表型属性值 书写在单行时，, 后必须跟一个空格。 123456789101112/* good */.ui-tbl&#123; display: table; width: 100%; box-sizing: border-box;&#125;.avatar &#123; font-family: Arial, sans-serif; &#125;/* bad */.ui-tbl&#123;display: table;width: 100%;box-sizing: border-box;&#125;.avatar &#123;font-family: Arial,sans-serif;&#125; 顺序 按功能分组书写，并以 Formatting Model（布局方式、位置） &gt; Box Model（尺寸） &gt; Typographic（文本相关） &gt; Visual（视觉效果） 的顺序书写，以提高代码的可读性。 解释： Formatting Model 相关属性包括：position / top / right / bottom / left / float / display / overflow 等 Box Model 相关属性包括：border / margin / padding / width / height 等 Typographic 相关属性包括：font / line-height / text-align / word-wrap 等 Visual 相关属性包括：background / color / transition / list-style / animation / transform 等 另外，如果包含 content 属性，应放在最前面。 123456.sidebar &#123; position: absolute; top: 50px; left: 0; overflow-x: hidden; width: 200px; padding: 5px; border: 1px solid #ddd; font-size: 14px; line-height: 20px; background: #f5f5f5; color: #333; -webkit-transition: color 1s; -moz-transition: color 1s; transition: color 1s; &#125; 注释 建议使用块注释 /* ... */，注释独占一行。 独立的CSS模块，要添加注释说明 选择器 如无必要，不得为 id、class 选择器添加类型选择器进行限定 解释：在性能和维护性上，都有一定的影响。 12345/* good */#error,.danger-message &#123; font-color: #c00; &#125;/* bad */dialog#error, p.danger-message &#123; font-color: #c00; &#125; 属性选择器中的值必须用双引号包围。 选择器嵌套层级应少于 4 级 尽量使用class选择器 避免直接使用类型选择器 避免空的class 禁用通配符 对需要javascript操作的元素加上ID，ID尽量以驼峰命名法命名。 12345678910111213/* good */ div.vip-wrap ul.vip-list li.vip-item*3.vip-item &#123; ... &#125;/* bad */ div.vip-wrap ul.vip-list li*3.vip-wrap .vip-list li &#123; ... &#125; 属性缩写 在可以使用缩写的情况下，尽量使用属性缩写。 1234567891011/* good */.post &#123; font: 12px/1.5 arial, sans-serif;&#125;/* bad */.post &#123; font-family: arial, sans-serif; font-size: 12px; line-height: 1.5;&#125; 使用 border / margin / padding 等缩写时，应注意隐含值对实际数值的影响，确实需要设置多个方向的值时才使用缩写。解释：border / margin / padding 等缩写会同时设置多个属性的值，容易覆盖不需要覆盖的设定。如某些方向需要继承其他声明的值，则应该分开设置。 命令规则 尽量使用BEM命令规则(Block-Element-Modifie)，但可以适当修改，结合组合式命名更加灵活。 模块名/业务名 - 区域名/元素名 - 状态/颜色 全局组件以 ‘ui-‘ 开头 12345678 /* Msg 弹窗模块 */.ui-msg &#123;&#125;.ui-msg.alert &#123;&#125;.ui-msg.prompt &#123;&#125;.ui-msg.actions &#123;&#125;.ui-msg-hd &#123;&#125;.ui-msg-bd &#123;&#125;.ui-msg-ft &#123;&#125; z-index 在使用relative 或 absolute 定位时，尽量指定固定的z-index的值，值的大小为10倍数，小于999999; 值与单位数值 当数值为 0 - 1 之间的小数时，省略整数部分的 0 123456789/* good */panel &#123; opacity: .8;&#125;/* bad */panel &#123; opacity: 0.8;&#125; 路径 url() 函数中的路径不加引号。 url() 函数中的绝对路径可省去协议名。 123body &#123; background: url(//baidu.com/img/bg.png) no-repeat 0 0;&#125; 长度 长度为 0 时须省略单位。 (也只有长度单位可省) 123456789/* good */body &#123; padding: 0 5px;&#125;/* bad */body &#123; padding: 0px 5px;&#125; 颜色 颜色值可以缩写时，必须使用缩写形式。 123456789/* good */.success &#123; background-color: #aca;&#125;/* bad */.success &#123; background-color: #aaccaa;&#125; 颜色值不允许使用命名色值。 123456789/* good */.success &#123; color: #90ee90;&#125;/* bad */.success &#123; color: lightgreen;&#125; 边框 在定义无边框样式时，使用 0 代替 none。 123456789/* good */.foo &#123; border: 0;&#125;/* bad */.foo &#123; border: none;&#125;","raw":null,"content":null,"categories":[{"name":"web开发","slug":"web开发","permalink":"http://www.qiakr.com/categories/web开发/"}],"tags":[]},{"title":"Javascript 编码指南","slug":"javascript-style-guide","date":"2016-05-07T06:23:18.000Z","updated":"2016-05-07T07:22:14.000Z","comments":true,"path":"2016/05/07/javascript-style-guide/","link":"","permalink":"http://www.qiakr.com/qkfe/2016/05/07/javascript-style-guide/","excerpt":"前言总所周知，javascript 是一种语法极其灵活的语言。变量随时用随时可以声明；语句结束符可以不要；字符串和数字也可以相加；参数多一个少一个也不会报错。没错，当你从 C/C++ 和 Java 严格的语法规定之下，转向 JavaScript 语言，会觉得自由了很多，轻松了很多。 语法松散是 JavaScript 重要的特征。它灵活易懂，给开发人员带来了很多方便，但如果编写过程中不注意，代码的调试成本和维护成本则会无形地增加。JavaScript 编码会随应被直接发送到客户端的浏览器，代码规范不只是代码质量的保证，也影响到产品的长期信誉。 本文档的目标是使 JavaScript 代码风格保持一致，良好的编程风格有助于写出质量更高、错误更少、更易于维护的程序。","keywords":null,"text":"前言总所周知，javascript 是一种语法极其灵活的语言。变量随时用随时可以声明；语句结束符可以不要；字符串和数字也可以相加；参数多一个少一个也不会报错。没错，当你从 C/C++ 和 Java 严格的语法规定之下，转向 JavaScript 语言，会觉得自由了很多，轻松了很多。 语法松散是 JavaScript 重要的特征。它灵活易懂，给开发人员带来了很多方便，但如果编写过程中不注意，代码的调试成本和维护成本则会无形地增加。JavaScript 编码会随应被直接发送到客户端的浏览器，代码规范不只是代码质量的保证，也影响到产品的长期信誉。 本文档的目标是使 JavaScript 代码风格保持一致，良好的编程风格有助于写出质量更高、错误更少、更易于维护的程序。 JavaScript 语言规范12变量 常量 保留字 数组 字符串 函数 块内函数声明 闭包 Array和Object直接量对象原型 True与False 类型分配&amp;强制转换 浮点数精度 命名规范 JavaScript 编码风格12文件编码 分号 逗号 空格 大括号 单引号、双引号 空行 二元和三元操作符 语句块 注释 全局变量 全等 JavaScript 语言规范变量 声明变量必须加上 var 关键字 当你没有写 var, 变量就会暴露在全局上下文中, 这样很可能会和现有变量冲突. 另外, 如果没有加上, 很难明确该变量的作用域是什么, 变量也很可能像在局部作用域中, 很轻易地泄漏到 Document 或者 Window 中, 所以务必用 var 去声明变量. 常量 常量使用大写字符并用下划线分隔，如：PAGE_CONFIG 保留字 不要使用保留字，在IE8中不起作用 1234567891011// goodvar superman = &#123; defaults: &#123; clark: 'kent' &#125;, hidden: true&#125;;// badvar superman = &#123; default: &#123; clark: 'kent' &#125;, private: true&#125;; 数组 添加数组元素时，使用push而不是直接添加 1234567var someStack = [];// goodsomeStack.push('abracadabra');// badsomeStack[someStack.length] = 'abracadabra'; 需要复制数组时，可以使用slice 1234567891011var len = items.length;var itemsCopy = [];var i;// gooditemsCopy = items.slice();// badfor (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i];&#125; 使用slice将类数组对象转为数组 1234function trigger() &#123; var args = Array.prototype.slice.call(arguments); ...&#125; 遍历数组不使用 for in 数组对象可能存在数字以外的属性, 这种情况下 for in 不会得到正确结果. 123456789101112var arr = ['a', 'b', 'c'];arr.other = 'other things'; // 这里仅作演示, 实际中应使用Object类型// 正确的遍历方式for (var i = 0, len = arr.length; i &lt; len; i++) &#123; console.log(i);&#125;// 错误的遍历方式for (i in arr) &#123; console.log(i);&#125; 清空数组使用 .length = 0 字符串 对字符串使用单引号 超过80个字符的字符串应该使用字符串连接符进行跨行（对长字符串过度使用连接符将会影响性能） 12345678910111213// goodvar errorMessage = 'This is a super long error that was thrown because ' + 'of Batman. When you stop to think about how Batman had anything to do ' + 'with this, you would get nowhere fast.';// badvar errorMessage = 'This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.';// badvar errorMessage = 'This is a super long error that was thrown because \\of Batman. When you stop to think about how Batman had anything to do \\with this, you would get nowhere \\fast.'; 使用 join() 来创建字符串 通常写法： 1234567891011function listHtml(items) &#123; var html = '&lt;div class=\"foo\"&gt;'; for (var i = 0; i &lt; items.length; ++i) &#123; if (i &gt; 0) &#123; html += ', '; &#125; html += itemHtml(items[i]); &#125; html += '&lt;/div&gt;'; return html;&#125; 但这样在 IE 下非常慢, 可以用下面的方式 1234567function listHtml(items) &#123; var html = []; for (var i = 0; i &lt; items.length; ++i) &#123; html[i] = itemHtml(items[i]); &#125; return '&lt;div class=\"foo\"&gt;' + html.join(', ') + '&lt;/div&gt;';&#125; 也可以是用数组作为字符串构造器, 然后通过 myArray.join(‘’) 转换成字符串. 不过由于赋值操作快于数组的 push(), 所以尽量使用赋值操作. 函数 不要在非函数块中(if, while, etc)声明函数，尽管浏览器允许你分配函数给一个变量，但坏消息是，不同的浏览器用不同的方式解析它 1234567891011121314// goodvar test;if (currentUser) &#123; test = function test() &#123; console.log('Yup.'); &#125;;&#125;// badif (currentUser) &#123; function test() &#123; console.log('Nope.'); &#125;&#125; 不要命名一个参数为arguments，否则它将优先于传递给每个函数作用域中的arguments对象 123456789// goodfunction yup(name, options, args) &#123; // ...stuff...&#125;// badfunction nope(name, options, arguments) &#123; // ...stuff...&#125; 在作用域顶端对变量赋值，这有助于避免变量声明问题和与声明提升相关的问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// goodfunction() &#123; var name = getName(); test(); console.log('doing stuff..'); //..other stuff.. if (name === 'test') &#123; return false; &#125; return name;&#125;// badfunction() &#123; test(); console.log('doing stuff..'); //..other stuff.. var name = getName(); if (name === 'test') &#123; return false; &#125; return name;&#125;// goodfunction() &#123; if (!arguments.length) &#123; return false; &#125; var name = getName(); return true;&#125;// badfunction() &#123; var name = getName(); if (!arguments.length) &#123; return false; &#125; return true;&#125; 函数声明会提升变量名和函数体 123456789101112131415161718// good function example() &#123; superPower(); // =&gt; Flying function superPower() &#123; console.log('Flying'); &#125;&#125;// badfunction example() &#123; superPower(); // =&gt; TypeError superPower is not a function var superPower = function() &#123; console.log('Flying'); &#125;&#125; 块内函数声明 不要在块内声明函数 123456789// goodif (x) &#123; var foo = function() &#123;&#125;&#125;// badif (x) &#123; function foo() &#123;&#125;&#125; 块内声明函数, 但它不属于 ECMAScript 规范, 各个浏览器糟糕的实现相互不兼容, 有些也与未来 ECMAScript 草案相违背 ECMAScript 只允许在脚本的根语句或函数中声明函数. 如果确实需要在块中定义函数, 建议使用函数表达式来初始化变量: 闭包 小心使用闭包 闭包保留了一个指向它封闭作用域的指针, 所以, 在给 DOM 元素附加闭包时, 很可能会产生循环引用, 进一步导致内存泄漏. 比如下面的代码: 123function foo(element, a, b) &#123; element.onclick = function() &#123; /* uses a and b */ &#125;;&#125; 这里, 即使没有使用 element, 闭包也保留了 element, a 和 b 的引用, . 由于 element 也保留了对闭包的引用, 这就产生了循环引用, 这就不能被 GC 回收. 这种情况下, 可将代码重构为: 1234567function foo(element, a, b) &#123; element.onclick = bar(a, b);&#125;function bar(a, b) &#123; return function() &#123; /* uses a and b */ &#125;&#125; Array 和 Object 直接量 使用 Array 和 Object 语法, 而不使用 Array 和 Object 构造器. 12345678910111213141516//goodvar a = [1, 2, 3];var o2 = &#123; a: 0, b: 1, c: 2, 'strange key': 3&#125;;//badvar a1 = new Array(1, 2, 3);var o2 = new Object();o2.a = 0;o2.b = 1;o2.c = 2;o2['strange key'] = 3; 对象原型 不要修改内置对象的原型，如 Object.prototype 和 Array.prototype 的原型，给添加内置原型方法很容易和其它库冲突或者可能与将来ES升级不兼容。 True 与 False下面的布尔表达式都返回 false: null undefined &#39;&#39; 空字符串 0 数字0 但小心下面的, 可都返回 true: &#39;0&#39; 字符串0 [] 空数组 {} 空对象 如果你想判断是一个变量是否为null/&#39;&#39;/0/false 12345// good if(x)&#123; ... &#125;// badif(x != null)&#123; ... &#125; 还有很多需要注意的地方 以下都为true 1234567891011121314151617Boolean('0') == true'0' != true0 != null0 == []0 == falseBoolean(null) == falsenull != truenull != falseBoolean(undefined) == falseundefined != trueundefined != falseBoolean([]) == true[] != true[] == falseBoolean(&#123;&#125;) == true&#123;&#125; != true&#123;&#125; != false 遍历 Node ListNode lists 是通过给节点迭代器加一个过滤器来实现的. 这表示获取他的属性, 如 length 的时间复杂度为 O(n), 通过 length 来遍历整个列表需要 O(n^2). 1234var paragraphs = document.getElementsByTagName('p');for (var i = 0; i &lt; paragraphs.length; i++) &#123; doSomething(paragraphs[i]);&#125; 这样做会更好: 1234var paragraphs = document.getElementsByTagName('p');for (var i = 0, paragraph; paragraph = paragraphs[i]; i++) &#123; doSomething(paragraph);&#125; 这种方法对所有的 collections 和数组(只要数组不包含 falsy 值) 都适用. 在上面的例子中, 也可以通过 firstChild 和 nextSibling 来遍历孩子节点. 1234var parentNode = document.getElementById('foo');for (var child = parentNode.firstChild; child; child = child.nextSibling) &#123; doSomething(child);&#125; 类型分配&amp;强制转换 执行强制类型转换的语句 12345678910111213// =&gt; this.reviewScore = 9;// goodvar totalScore = this.reviewScore + ' total score';// badvar totalScore = this.reviewScore + '';// goodvar totalScore = '' + this.reviewScore;// badvar totalScore = '' + this.reviewScore + ' total score'; 使用parseInt对Numbers进行转换，并带一个进制作为参数 12345678910111213141516171819var inputValue = '4';// badvar val = new Number(inputValue);// badvar val = +inputValue;// badvar val = inputValue &gt;&gt; 0;// badvar val = parseInt(inputValue);// goodvar val = Number(inputValue);// goodvar val = parseInt(inputValue, 10); 注意： 当使用位运算时，Numbers被视为64位值，但是位运算总是返回32位整型。对于整型值大于32位的进行位运算将导致不可预见的行为。最大的有符号32位整数是2,147,483,647 12345672147483647 &gt;&gt; 0 //=&gt; 21474836472147483648 &gt;&gt; 0 //=&gt; -21474836482147483649 &gt;&gt; 0 //=&gt; -2147483647~~2147483647 //=&gt; 2147483647~~2147483648 //=&gt; -2147483648~~2147483649 //=&gt; -2147483647 浮点数精度使用了IEEE 754 浮点数格式来存储浮点类型的任何编程语言（C/C++/C#/Java 等等）都存在精度丢失问题。 在 C#、Java 中，提供了 Decimal、BigDecimal 封装类来进行相应的处理，才避开了精度丢失。 原生JS并没有提供相应的API, 寻么就会出现以下类似怪异情况： 12340.1 + 0.2 == 0.300000000000000049999999999999999 == 10000000000000000; // true0.05 + 0.2 == 0.25 // true0.05 + 0.9 == 0.95 // false 对于这人问题这里不做展开，只提供解决方案，可使用 math.js 对数据进行运算 详情解释见 玉伯的JavaScript 中小数和大整数的精度丢失 命名规范 避免单字母名称，让名称具有描述性 123456789// badfunction q() &#123; // ...stuff...&#125;// goodfunction query() &#123; // ..stuff..&#125; 当命名对象、函数和实例时使用骆驼拼写法 1234567891011121314// badvar OBJEcttsssss = &#123;&#125;;var this_is_my_object = &#123;&#125;;function c() &#123;&#125;var u = new user(&#123; name: 'Bob Parr'&#125;);// goodvar thisIsMyObject = &#123;&#125;;function thisIsMyFunction() &#123;&#125;var user = new User(&#123; name: 'Bob Parr'&#125;); 当命名构造函数或类名时，使用驼峰式写法 1234567891011121314151617// badfunction user(options) &#123; this.name = options.name;&#125;var bad = new user(&#123; name: 'nope'&#125;);// goodfunction User(options) &#123; this.name = options.name;&#125;var good = new User(&#123; name: 'yup'&#125;); 命名私有属性时使用前置下划线 123456// badthis.__firstName__ = 'Panda';this.firstName_ = 'Panda';// goodthis._firstName = 'Panda'; 保存this引用时使用_this 1234567891011121314151617181920212223// badfunction() &#123; var self = this; return function() &#123; console.log(self); &#125;;&#125;// badfunction() &#123; var that = this; return function() &#123; console.log(that); &#125;;&#125;// goodfunction() &#123; var _this = this; return function() &#123; console.log(_this); &#125;;&#125; JavaScript 编码风格文件编码 JavaScript 文件使用无 BOM 的 UTF-8 编码。 分号 总是以分号结尾 12345678910111213141516171819202122232425262728293031323334// goodvar myMethod = function() &#123; return 42;&#125;;(function() &#123; // Some initialization code wrapped in a function to create a scope for locals.&#125;)();// badvar myMethod = function() &#123; return 42;&#125;(function() &#123; // Some initialization code wrapped in a function to create a scope for locals.&#125;)();// Uncaught TypeError: (intermediate value)(...) is not a function(…)//语句会解释成, 一个函数带一匿名函数作为参数而被调用, 返回42后, 又一次被\"调用\", 这就导致了错误.// good(function() &#123; var name = 'Skywalker'; return name;&#125;)();或;(function() &#123; var name = 'Skywalker'; return name;&#125;)()// bad(function() &#123; var name = 'Skywalker' return name&#125;)() JavaScript 的语句以分号作为结束符, 除非可以非常准确推断某结束位置才会省略分号. 语句中声明了函数/对象/数组直接量, 但 闭括号(&apos;}&apos;或&apos;]&apos;)并不足以表示该语句的结束. 在 JavaScript 中, 只有当语句后的下一个符号是后缀或括号运算符时, 才会认为该语句的结束. 遗漏分号有时会出现很奇怪的结果, 所以确保语句以分号结束. 逗号 一次性申明多个变量或申明一个对象，逗号置尾 123456789101112131415161718192021// goodvar foo = 1, bar = 2, baz = 3;var obj = &#123; foo: 1, bar: 2, baz: 3&#125;;// badvar foo = 1 , bar = 2 , baz = 3;var obj = &#123; foo: 1 , bar: 2 , baz: 3&#125;; 空格 函数名称和条件语句后面不加空格 12345678910111213141516// goodfunction foo() &#123; return \"bar\";&#125;if(true) &#123; //...&#125;// badfunction foo () &#123; return \"bar\";&#125;if (true) &#123; //...&#125; 参数与括号之间无空格 12345678910111213// good function fn(arg1, arg2) &#123;//orif (true) &#123;// badfunction fn( arg1, arg2 ) &#123; // ...&#125;if ( true ) &#123; // ...&#125; 对象字面量冒号后面加空格，前面不加 12345678910111213// good&#123; foo: 1, bar: 2, baz: 3&#125;// bad&#123; foo : 1, bar : 2, baz : 3&#125; 在左大括号之前留一个空格 123456789// goodfunction test() &#123; console.log('test');&#125;// badfunction test()&#123; console.log('test');&#125; 用空白分隔运算符 12345// goodvar x = y + 5;// badvar x=y+5; 使用软制表符设置两个空格 1234567891011121314// badfunction() &#123;∙∙∙∙var name;&#125;// badfunction() &#123;∙var name;&#125;// goodfunction() &#123;∙∙var name;&#125; 当调用很长的方法链时使用缩进，可以强调这行是方法调用，不是新的语句 12345678910111213141516171819202122232425262728293031323334// bad$('#items').find('.selected').highlight().end().find('.open').updateCount();// bad$('#items'). find('.selected'). highlight(). end(). find('.open'). updateCount();// good$('#items') .find('.selected') .highlight() .end() .find('.open') .updateCount();// badvar leds = stage.selectAll('.led').data(data).enter().append('svg:svg').classed('led', true) .attr('width', (radius + margin) * 2).append('svg:g') .attr('transform', 'translate(' + (radius + margin) + ',' + (radius + margin) + ')') .call(tron.led);// goodvar leds = stage.selectAll('.led') .data(data) .enter().append('svg:svg') .classed('led', true) .attr('width', (radius + margin) * 2) .append('svg:g') .attr('transform', 'translate(' + (radius + margin) + ',' + (radius + margin) + ')') .call(tron.led); 大括号 表示区块起首的大括号，不要另起一行。 12345678910// goodreturn &#123; key : value;&#125;;// badreturn&#123; key:value;&#125;; 代码的原意，是要返回一个对象，但实际上返回的是undefined，因为Javascript自动在return语句后面添加了分号。 单引号、双引号 统一使用单引号 1var msg = 'This is some HTML'; 单引号 (&apos;) 优于双引号 (&quot;). 当你创建一个包含 HTML 代码的字符串时就知道它的好处了. 空行 使用空行来划分一组逻辑上相关联的代码片段. 1234567doSomethingTo(x);doSomethingElseTo(x);andThen(x);nowDoSomethingWith(y);andNowWith(z); 二元和三元操作符 操作符始终跟随着前行, 这样就不用顾虑分号的隐式插入问题. 如果一行实在放不下, 还是按照下面的缩进风格来换行. 1234567891011121314151617181920var x = a ? b : c; // All on one line if it will fit.// Indentation +4 is OK.var y = a ? longButSimpleOperandB : longButSimpleOperandC;// Indenting to the line position of the first operand is also OK.var z = a ? moreComplicatedB : moreComplicatedC;// 二元操作符后面的必须是一个完整的执行语句// badvar isShow = true, x1;isShow ? x1=2;//Uncaught SyntaxError: Unexpected token ;(…)// goodvar isShow = true, x1;isShow ? (x1=2); 二元布尔操作符是可短路的, 只有在必要时才会计算到最后一项.&quot;||&quot; 被称作为 default 操作符 123456789101112131415function foo(opt_win) &#123; var win; if (opt_win) &#123; win = opt_win; &#125; else &#123; win = window; &#125; // ...&#125;// 可简化为function foo(opt_win) &#123; var win = opt_win || window; // ...&#125; “&amp;&amp;” 也可简短代码 1234567891011121314151617if (node) &#123; if (node.kids) &#123; if (node.kids[index]) &#123; foo(node.kids[index]); &#125; &#125;&#125;// 可简化为if (node &amp;&amp; node.kids &amp;&amp; node.kids[index]) &#123; foo(node.kids[index]);&#125;//或者var kid = node &amp;&amp; node.kids &amp;&amp; node.kids[index];if (kid) &#123; foo(kid);&#125; 语句块 对于使用if和else的多行语句块，把else和if语句块的右大括号放在同一行 12345678910111213141516// goodif (test) &#123; thing1(); thing2();&#125; else &#123; thing3();&#125;// badif (test) &#123; thing1(); thing2();&#125;else &#123; thing3();&#125; 注释 多行注释使用/* … /，需包含一个描述、所有参数的具体类型和值以及返回值 123456789101112131415161718192021222324252627// good/** * make() returns a new element * based on the passed in tag name * * @param &#123;String&#125; tag * @return &#123;Element&#125; element */function make(tag) &#123; // ...stuff... return element;&#125;// bad// make() returns a new element// based on the passed in tag name//// @param &#123;String&#125; tag// @return &#123;Element&#125; elementfunction make(tag) &#123; // ...stuff... return element;&#125; 单行注释使用//，把单行注释放在语句的上一行，并且在注释之前空一行 123456789101112131415161718// goodfunction getType() &#123; console.log('fetching type...'); // set the default type to 'no type' var type = this._type || 'no type'; return type;&#125;// badfunction getType() &#123; console.log('fetching type...'); // set the default type to 'no type' var type = this._type || 'no type'; return type;&#125; 使用//TODO:给问题解决方案作注释 1234567function Calculator() &#123; // TODO: total should be configurable by an options param this.total = 0; return this;&#125; 全局变量 避免使用全局变量；如果不得不使用，用大写字母表示变量名，比如UPPER_CASE。 == 和 === 尽量使用’===’来进行逻辑等的判断，用’!==’进行逻辑不等的判断 ==作逻辑等判断时，会先进行类型转换后再进行比较。===则不会。因而，==进行的判断结果可能产生偏差。 12345678910111213141516var valueA = \"1\"; var valueB = 1; if ( valueA == valueB) &#123; alert(\"Equal\"); &#125; else &#123; alert(\"Not equal\") &#125; //output: \"Equal\"if ( valueA === valueB) &#123; alert(\"Equal\"); &#125; else &#123; alert(\"Not equal\") &#125; //output: \"Not equal\"","raw":null,"content":null,"categories":[{"name":"web开发","slug":"web开发","permalink":"http://www.qiakr.com/categories/web开发/"}],"tags":[]}]}