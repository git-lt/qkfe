{"meta":{"title":"洽客前端","subtitle":"洽客技术团队 （QKED）","description":"Talk is cheap, Show me the code.","author":"LT","url":"http://www.qiakr.com"},"pages":[],"posts":[{"title":"Javascript 编码指南","slug":"javascript-style-guide","date":"2016-05-07T06:23:18.000Z","updated":"2016-05-07T07:00:14.000Z","comments":true,"path":"2016/05/07/javascript-style-guide/","link":"","permalink":"http://www.qiakr.com/2016/05/07/javascript-style-guide/","excerpt":"前言总所周知，javascript 是一种语法极其灵活的语言。变量随时用随时可以声明；语句结束符可以不要；字符串和数字也可以相加；参数多一个少一个也不会报错。没错，当你从 C/C++ 和 Java 严格的语法规定之下，转向 JavaScript 语言，会觉得自由了很多，轻松了很多。 语法松散是 JavaScript 重要的特征。它灵活易懂，给开发人员带来了很多方便，但如果编写过程中不注意，代码的调试成本和维护成本则会无形地增加。JavaScript 编码会随应被直接发送到客户端的浏览器，代码规范不只是代码质量的保证，也影响到产品的长期信誉。 本文档的目标是使 JavaScript 代码风格保持一致，良好的编程风格有助于写出质量更高、错误更少、更易于维护的程序。","keywords":null,"text":"前言总所周知，javascript 是一种语法极其灵活的语言。变量随时用随时可以声明；语句结束符可以不要；字符串和数字也可以相加；参数多一个少一个也不会报错。没错，当你从 C/C++ 和 Java 严格的语法规定之下，转向 JavaScript 语言，会觉得自由了很多，轻松了很多。 语法松散是 JavaScript 重要的特征。它灵活易懂，给开发人员带来了很多方便，但如果编写过程中不注意，代码的调试成本和维护成本则会无形地增加。JavaScript 编码会随应被直接发送到客户端的浏览器，代码规范不只是代码质量的保证，也影响到产品的长期信誉。 本文档的目标是使 JavaScript 代码风格保持一致，良好的编程风格有助于写出质量更高、错误更少、更易于维护的程序。 JavaScript 语言规范12变量 常量 保留字 数组 字符串 函数 块内函数声明 闭包 Array和Object直接量对象原型 True与False 类型分配&amp;强制转换 浮点数精度 命名规范 JavaScript 编码风格12文件编码 分号 逗号 空格 大括号 单引号、双引号 空行 二元和三元操作符 语句块 注释 全局变量 全等 JavaScript 语言规范变量 声明变量必须加上 var 关键字 当你没有写 var, 变量就会暴露在全局上下文中, 这样很可能会和现有变量冲突. 另外, 如果没有加上, 很难明确该变量的作用域是什么, 变量也很可能像在局部作用域中, 很轻易地泄漏到 Document 或者 Window 中, 所以务必用 var 去声明变量. 常量 常量使用大写字符并用下划线分隔，如：PAGE_CONFIG 保留字 不要使用保留字，在IE8中不起作用 1234567891011// goodvar superman = &#123; defaults: &#123; clark: &apos;kent&apos; &#125;, hidden: true&#125;;// badvar superman = &#123; default: &#123; clark: &apos;kent&apos; &#125;, private: true&#125;; 数组 添加数组元素时，使用push而不是直接添加 1234567var someStack = [];// goodsomeStack.push(&apos;abracadabra&apos;);// badsomeStack[someStack.length] = &apos;abracadabra&apos;; 需要复制数组时，可以使用slice 1234567891011var len = items.length;var itemsCopy = [];var i;// gooditemsCopy = items.slice();// badfor (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i];&#125; 使用slice将类数组对象转为数组 1234function trigger() &#123; var args = Array.prototype.slice.call(arguments); ...&#125; 遍历数组不使用 for in 数组对象可能存在数字以外的属性, 这种情况下 for in 不会得到正确结果. 123456789101112var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];arr.other = &apos;other things&apos;; // 这里仅作演示, 实际中应使用Object类型// 正确的遍历方式for (var i = 0, len = arr.length; i &lt; len; i++) &#123; console.log(i);&#125;// 错误的遍历方式for (i in arr) &#123; console.log(i);&#125; 清空数组使用 .length = 0 字符串 对字符串使用单引号 超过80个字符的字符串应该使用字符串连接符进行跨行（对长字符串过度使用连接符将会影响性能） 12345678910111213// goodvar errorMessage = &apos;This is a super long error that was thrown because &apos; + &apos;of Batman. When you stop to think about how Batman had anything to do &apos; + &apos;with this, you would get nowhere fast.&apos;;// badvar errorMessage = &apos;This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.&apos;;// badvar errorMessage = &apos;This is a super long error that was thrown because \\of Batman. When you stop to think about how Batman had anything to do \\with this, you would get nowhere \\fast.&apos;; 使用 join() 来创建字符串 通常写法： 1234567891011function listHtml(items) &#123; var html = &apos;&lt;div class=&quot;foo&quot;&gt;&apos;; for (var i = 0; i &lt; items.length; ++i) &#123; if (i &gt; 0) &#123; html += &apos;, &apos;; &#125; html += itemHtml(items[i]); &#125; html += &apos;&lt;/div&gt;&apos;; return html;&#125; 但这样在 IE 下非常慢, 可以用下面的方式 1234567function listHtml(items) &#123; var html = []; for (var i = 0; i &lt; items.length; ++i) &#123; html[i] = itemHtml(items[i]); &#125; return &apos;&lt;div class=&quot;foo&quot;&gt;&apos; + html.join(&apos;, &apos;) + &apos;&lt;/div&gt;&apos;;&#125; 也可以是用数组作为字符串构造器, 然后通过 myArray.join(‘’) 转换成字符串. 不过由于赋值操作快于数组的 push(), 所以尽量使用赋值操作. 函数 不要在非函数块中(if, while, etc)声明函数，尽管浏览器允许你分配函数给一个变量，但坏消息是，不同的浏览器用不同的方式解析它 1234567891011121314// goodvar test;if (currentUser) &#123; test = function test() &#123; console.log(&apos;Yup.&apos;); &#125;;&#125;// badif (currentUser) &#123; function test() &#123; console.log(&apos;Nope.&apos;); &#125;&#125; 不要命名一个参数为arguments，否则它将优先于传递给每个函数作用域中的arguments对象 123456789// goodfunction yup(name, options, args) &#123; // ...stuff...&#125;// badfunction nope(name, options, arguments) &#123; // ...stuff...&#125; 在作用域顶端对变量赋值，这有助于避免变量声明问题和与声明提升相关的问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// goodfunction() &#123; var name = getName(); test(); console.log(&apos;doing stuff..&apos;); //..other stuff.. if (name === &apos;test&apos;) &#123; return false; &#125; return name;&#125;// badfunction() &#123; test(); console.log(&apos;doing stuff..&apos;); //..other stuff.. var name = getName(); if (name === &apos;test&apos;) &#123; return false; &#125; return name;&#125;// goodfunction() &#123; if (!arguments.length) &#123; return false; &#125; var name = getName(); return true;&#125;// badfunction() &#123; var name = getName(); if (!arguments.length) &#123; return false; &#125; return true;&#125; 函数声明会提升变量名和函数体 123456789101112131415161718// good function example() &#123; superPower(); // =&gt; Flying function superPower() &#123; console.log(&apos;Flying&apos;); &#125;&#125;// badfunction example() &#123; superPower(); // =&gt; TypeError superPower is not a function var superPower = function() &#123; console.log(&apos;Flying&apos;); &#125;&#125; 块内函数声明 不要在块内声明函数 123456789// goodif (x) &#123; var foo = function() &#123;&#125;&#125;// badif (x) &#123; function foo() &#123;&#125;&#125; 块内声明函数, 但它不属于 ECMAScript 规范, 各个浏览器糟糕的实现相互不兼容, 有些也与未来 ECMAScript 草案相违背 ECMAScript 只允许在脚本的根语句或函数中声明函数. 如果确实需要在块中定义函数, 建议使用函数表达式来初始化变量: 闭包 小心使用闭包 闭包保留了一个指向它封闭作用域的指针, 所以, 在给 DOM 元素附加闭包时, 很可能会产生循环引用, 进一步导致内存泄漏. 比如下面的代码: 123function foo(element, a, b) &#123; element.onclick = function() &#123; /* uses a and b */ &#125;;&#125; 这里, 即使没有使用 element, 闭包也保留了 element, a 和 b 的引用, . 由于 element 也保留了对闭包的引用, 这就产生了循环引用, 这就不能被 GC 回收. 这种情况下, 可将代码重构为: 1234567function foo(element, a, b) &#123; element.onclick = bar(a, b);&#125;function bar(a, b) &#123; return function() &#123; /* uses a and b */ &#125;&#125; Array 和 Object 直接量 使用 Array 和 Object 语法, 而不使用 Array 和 Object 构造器. 12345678910111213141516//goodvar a = [1, 2, 3];var o2 = &#123; a: 0, b: 1, c: 2, &apos;strange key&apos;: 3&#125;;//badvar a1 = new Array(1, 2, 3);var o2 = new Object();o2.a = 0;o2.b = 1;o2.c = 2;o2[&apos;strange key&apos;] = 3; 对象原型 不要修改内置对象的原型，如 Object.prototype 和 Array.prototype 的原型，给添加内置原型方法很容易和其它库冲突或者可能与将来ES升级不兼容。 True 与 False下面的布尔表达式都返回 false: null undefined &#39;&#39; 空字符串 0 数字0 但小心下面的, 可都返回 true: &#39;0&#39; 字符串0 [] 空数组 {} 空对象 如果你想判断是一个变量是否为null/&#39;&#39;/0/false12345// good if(x)&#123; ... &#125;// badif(x != null)&#123; ... &#125; 还有很多需要注意的地方 以下都为true1234567891011121314151617Boolean(&apos;0&apos;) == true&apos;0&apos; != true0 != null0 == []0 == falseBoolean(null) == falsenull != truenull != falseBoolean(undefined) == falseundefined != trueundefined != falseBoolean([]) == true[] != true[] == falseBoolean(&#123;&#125;) == true&#123;&#125; != true&#123;&#125; != false 遍历 Node ListNode lists 是通过给节点迭代器加一个过滤器来实现的. 这表示获取他的属性, 如 length 的时间复杂度为 O(n), 通过 length 来遍历整个列表需要 O(n^2). 1234var paragraphs = document.getElementsByTagName(&apos;p&apos;);for (var i = 0; i &lt; paragraphs.length; i++) &#123; doSomething(paragraphs[i]);&#125; 这样做会更好: 1234var paragraphs = document.getElementsByTagName(&apos;p&apos;);for (var i = 0, paragraph; paragraph = paragraphs[i]; i++) &#123; doSomething(paragraph);&#125; 这种方法对所有的 collections 和数组(只要数组不包含 falsy 值) 都适用. 在上面的例子中, 也可以通过 firstChild 和 nextSibling 来遍历孩子节点. 1234var parentNode = document.getElementById(&apos;foo&apos;);for (var child = parentNode.firstChild; child; child = child.nextSibling) &#123; doSomething(child);&#125; 类型分配&amp;强制转换 执行强制类型转换的语句 12345678910111213// =&gt; this.reviewScore = 9;// goodvar totalScore = this.reviewScore + &apos; total score&apos;;// badvar totalScore = this.reviewScore + &apos;&apos;;// goodvar totalScore = &apos;&apos; + this.reviewScore;// badvar totalScore = &apos;&apos; + this.reviewScore + &apos; total score&apos;; 使用parseInt对Numbers进行转换，并带一个进制作为参数 12345678910111213141516171819var inputValue = &apos;4&apos;;// badvar val = new Number(inputValue);// badvar val = +inputValue;// badvar val = inputValue &gt;&gt; 0;// badvar val = parseInt(inputValue);// goodvar val = Number(inputValue);// goodvar val = parseInt(inputValue, 10); 注意： 当使用位运算时，Numbers被视为64位值，但是位运算总是返回32位整型。对于整型值大于32位的进行位运算将导致不可预见的行为。最大的有符号32位整数是2,147,483,647 12345672147483647 &gt;&gt; 0 //=&gt; 21474836472147483648 &gt;&gt; 0 //=&gt; -21474836482147483649 &gt;&gt; 0 //=&gt; -2147483647~~2147483647 //=&gt; 2147483647~~2147483648 //=&gt; -2147483648~~2147483649 //=&gt; -2147483647 浮点数精度使用了IEEE 754 浮点数格式来存储浮点类型的任何编程语言（C/C++/C#/Java 等等）都存在精度丢失问题。 在 C#、Java 中，提供了 Decimal、BigDecimal 封装类来进行相应的处理，才避开了精度丢失。 原生JS并没有提供相应的API, 寻么就会出现以下类似怪异情况： 12340.1 + 0.2 == 0.300000000000000049999999999999999 == 10000000000000000; // true0.05 + 0.2 == 0.25 // true0.05 + 0.9 == 0.95 // false 对于这人问题这里不做展开，只提供解决方案，可使用 math.js 对数据进行运算 详情解释见 玉伯的JavaScript 中小数和大整数的精度丢失 命名规范 避免单字母名称，让名称具有描述性 123456789// badfunction q() &#123; // ...stuff...&#125;// goodfunction query() &#123; // ..stuff..&#125; 当命名对象、函数和实例时使用骆驼拼写法 1234567891011121314// badvar OBJEcttsssss = &#123;&#125;;var this_is_my_object = &#123;&#125;;function c() &#123;&#125;var u = new user(&#123; name: &apos;Bob Parr&apos;&#125;);// goodvar thisIsMyObject = &#123;&#125;;function thisIsMyFunction() &#123;&#125;var user = new User(&#123; name: &apos;Bob Parr&apos;&#125;); 当命名构造函数或类名时，使用驼峰式写法 1234567891011121314151617// badfunction user(options) &#123; this.name = options.name;&#125;var bad = new user(&#123; name: &apos;nope&apos;&#125;);// goodfunction User(options) &#123; this.name = options.name;&#125;var good = new User(&#123; name: &apos;yup&apos;&#125;); 命名私有属性时使用前置下划线 123456// badthis.__firstName__ = &apos;Panda&apos;;this.firstName_ = &apos;Panda&apos;;// goodthis._firstName = &apos;Panda&apos;; 保存this引用时使用_this 1234567891011121314151617181920212223// badfunction() &#123; var self = this; return function() &#123; console.log(self); &#125;;&#125;// badfunction() &#123; var that = this; return function() &#123; console.log(that); &#125;;&#125;// goodfunction() &#123; var _this = this; return function() &#123; console.log(_this); &#125;;&#125; JavaScript 编码风格文件编码 JavaScript 文件使用无 BOM 的 UTF-8 编码。 分号 总是以分号结尾 12345678910111213141516171819202122232425262728293031323334// goodvar myMethod = function() &#123; return 42;&#125;;(function() &#123; // Some initialization code wrapped in a function to create a scope for locals.&#125;)();// badvar myMethod = function() &#123; return 42;&#125;(function() &#123; // Some initialization code wrapped in a function to create a scope for locals.&#125;)();// Uncaught TypeError: (intermediate value)(...) is not a function(…)//语句会解释成, 一个函数带一匿名函数作为参数而被调用, 返回42后, 又一次被&quot;调用&quot;, 这就导致了错误.// good(function() &#123; var name = &apos;Skywalker&apos;; return name;&#125;)();或;(function() &#123; var name = &apos;Skywalker&apos;; return name;&#125;)()// bad(function() &#123; var name = &apos;Skywalker&apos; return name&#125;)() JavaScript 的语句以分号作为结束符, 除非可以非常准确推断某结束位置才会省略分号. 语句中声明了函数/对象/数组直接量, 但 闭括号(&apos;}&apos;或&apos;]&apos;)并不足以表示该语句的结束. 在 JavaScript 中, 只有当语句后的下一个符号是后缀或括号运算符时, 才会认为该语句的结束. 遗漏分号有时会出现很奇怪的结果, 所以确保语句以分号结束. 逗号 一次性申明多个变量或申明一个对象，逗号置尾 123456789101112131415161718192021// goodvar foo = 1, bar = 2, baz = 3;var obj = &#123; foo: 1, bar: 2, baz: 3&#125;;// badvar foo = 1 , bar = 2 , baz = 3;var obj = &#123; foo: 1 , bar: 2 , baz: 3&#125;; 空格 函数名称和条件语句后面不加空格 12345678910111213141516// goodfunction foo() &#123; return &quot;bar&quot;;&#125;if(true) &#123; //...&#125;// badfunction foo () &#123; return &quot;bar&quot;;&#125;if (true) &#123; //...&#125; 参数与括号之间无空格 12345678910111213// good function fn(arg1, arg2) &#123;//orif (true) &#123;// badfunction fn( arg1, arg2 ) &#123; // ...&#125;if ( true ) &#123; // ...&#125; 对象字面量冒号后面加空格，前面不加 12345678910111213// good&#123; foo: 1, bar: 2, baz: 3&#125;// bad&#123; foo : 1, bar : 2, baz : 3&#125; 在左大括号之前留一个空格 123456789// goodfunction test() &#123; console.log(&apos;test&apos;);&#125;// badfunction test()&#123; console.log(&apos;test&apos;);&#125; 用空白分隔运算符 12345// goodvar x = y + 5;// badvar x=y+5; 使用软制表符设置两个空格 1234567891011121314// badfunction() &#123;∙∙∙∙var name;&#125;// badfunction() &#123;∙var name;&#125;// goodfunction() &#123;∙∙var name;&#125; 当调用很长的方法链时使用缩进，可以强调这行是方法调用，不是新的语句 12345678910111213141516171819202122232425262728293031323334// bad$(&apos;#items&apos;).find(&apos;.selected&apos;).highlight().end().find(&apos;.open&apos;).updateCount();// bad$(&apos;#items&apos;). find(&apos;.selected&apos;). highlight(). end(). find(&apos;.open&apos;). updateCount();// good$(&apos;#items&apos;) .find(&apos;.selected&apos;) .highlight() .end() .find(&apos;.open&apos;) .updateCount();// badvar leds = stage.selectAll(&apos;.led&apos;).data(data).enter().append(&apos;svg:svg&apos;).classed(&apos;led&apos;, true) .attr(&apos;width&apos;, (radius + margin) * 2).append(&apos;svg:g&apos;) .attr(&apos;transform&apos;, &apos;translate(&apos; + (radius + margin) + &apos;,&apos; + (radius + margin) + &apos;)&apos;) .call(tron.led);// goodvar leds = stage.selectAll(&apos;.led&apos;) .data(data) .enter().append(&apos;svg:svg&apos;) .classed(&apos;led&apos;, true) .attr(&apos;width&apos;, (radius + margin) * 2) .append(&apos;svg:g&apos;) .attr(&apos;transform&apos;, &apos;translate(&apos; + (radius + margin) + &apos;,&apos; + (radius + margin) + &apos;)&apos;) .call(tron.led); 大括号 表示区块起首的大括号，不要另起一行。 12345678910// goodreturn &#123; key : value;&#125;;// badreturn&#123; key:value;&#125;; 代码的原意，是要返回一个对象，但实际上返回的是undefined，因为Javascript自动在return语句后面添加了分号。 单引号、双引号 统一使用单引号 1var msg = &apos;This is some HTML&apos;; 单引号 (&apos;) 优于双引号 (&quot;). 当你创建一个包含 HTML 代码的字符串时就知道它的好处了. 空行 使用空行来划分一组逻辑上相关联的代码片段. 1234567doSomethingTo(x);doSomethingElseTo(x);andThen(x);nowDoSomethingWith(y);andNowWith(z); 二元和三元操作符 操作符始终跟随着前行, 这样就不用顾虑分号的隐式插入问题. 如果一行实在放不下, 还是按照下面的缩进风格来换行. 1234567891011121314151617181920var x = a ? b : c; // All on one line if it will fit.// Indentation +4 is OK.var y = a ? longButSimpleOperandB : longButSimpleOperandC;// Indenting to the line position of the first operand is also OK.var z = a ? moreComplicatedB : moreComplicatedC;// 二元操作符后面的必须是一个完整的执行语句// badvar isShow = true, x1;isShow ? x1=2;//Uncaught SyntaxError: Unexpected token ;(…)// goodvar isShow = true, x1;isShow ? (x1=2); 二元布尔操作符是可短路的, 只有在必要时才会计算到最后一项.&quot;||&quot; 被称作为 default 操作符 123456789101112131415function foo(opt_win) &#123; var win; if (opt_win) &#123; win = opt_win; &#125; else &#123; win = window; &#125; // ...&#125;// 可简化为function foo(opt_win) &#123; var win = opt_win || window; // ...&#125; “&amp;&amp;” 也可简短代码 1234567891011121314151617if (node) &#123; if (node.kids) &#123; if (node.kids[index]) &#123; foo(node.kids[index]); &#125; &#125;&#125;// 可简化为if (node &amp;&amp; node.kids &amp;&amp; node.kids[index]) &#123; foo(node.kids[index]);&#125;//或者var kid = node &amp;&amp; node.kids &amp;&amp; node.kids[index];if (kid) &#123; foo(kid);&#125; 语句块 对于使用if和else的多行语句块，把else和if语句块的右大括号放在同一行 12345678910111213141516// goodif (test) &#123; thing1(); thing2();&#125; else &#123; thing3();&#125;// badif (test) &#123; thing1(); thing2();&#125;else &#123; thing3();&#125; 注释 多行注释使用/* … /，需包含一个描述、所有参数的具体类型和值以及返回值 123456789101112131415161718192021222324252627// good/** * make() returns a new element * based on the passed in tag name * * @param &#123;String&#125; tag * @return &#123;Element&#125; element */function make(tag) &#123; // ...stuff... return element;&#125;// bad// make() returns a new element// based on the passed in tag name//// @param &#123;String&#125; tag// @return &#123;Element&#125; elementfunction make(tag) &#123; // ...stuff... return element;&#125; 单行注释使用//，把单行注释放在语句的上一行，并且在注释之前空一行 123456789101112131415161718// goodfunction getType() &#123; console.log(&apos;fetching type...&apos;); // set the default type to &apos;no type&apos; var type = this._type || &apos;no type&apos;; return type;&#125;// badfunction getType() &#123; console.log(&apos;fetching type...&apos;); // set the default type to &apos;no type&apos; var type = this._type || &apos;no type&apos;; return type;&#125; 使用//TODO:给问题解决方案作注释 1234567function Calculator() &#123; // TODO: total should be configurable by an options param this.total = 0; return this;&#125; 全局变量 避免使用全局变量；如果不得不使用，用大写字母表示变量名，比如UPPER_CASE。 == 和 === 尽量使用’===’来进行逻辑等的判断，用’!==’进行逻辑不等的判断 ==作逻辑等判断时，会先进行类型转换后再进行比较。===则不会。因而，==进行的判断结果可能产生偏差。 12345678910111213141516var valueA = &quot;1&quot;; var valueB = 1; if ( valueA == valueB) &#123; alert(&quot;Equal&quot;); &#125; else &#123; alert(&quot;Not equal&quot;) &#125; //output: &quot;Equal&quot;if ( valueA === valueB) &#123; alert(&quot;Equal&quot;); &#125; else &#123; alert(&quot;Not equal&quot;) &#125; //output: &quot;Not equal&quot;","raw":null,"content":null,"categories":[{"name":"web开发","slug":"web开发","permalink":"http://www.qiakr.com/categories/web开发/"}],"tags":[]}]}